{"ast":null,"code":"import { __spreadArray, __read } from '../../../ext/tslib/tslib.es6.js';\nimport { decode } from '../../../../../ext/base64-arraybuffer/dist/base64-arraybuffer.es5.js';\nimport { CanvasContext } from '../../types.js';\nvar webGLVarMap = new Map();\n\nfunction variableListFor(ctx, ctor) {\n  var contextMap = webGLVarMap.get(ctx);\n\n  if (!contextMap) {\n    contextMap = new Map();\n    webGLVarMap.set(ctx, contextMap);\n  }\n\n  if (!contextMap.has(ctor)) {\n    contextMap.set(ctor, []);\n  }\n\n  return contextMap.get(ctor);\n}\n\nfunction getContext(target, type) {\n  try {\n    if (type === CanvasContext.WebGL) {\n      return target.getContext('webgl') || target.getContext('experimental-webgl');\n    }\n\n    return target.getContext('webgl2');\n  } catch (e) {\n    return null;\n  }\n}\n\nvar WebGLVariableConstructorsNames = ['WebGLActiveInfo', 'WebGLBuffer', 'WebGLFramebuffer', 'WebGLProgram', 'WebGLRenderbuffer', 'WebGLShader', 'WebGLShaderPrecisionFormat', 'WebGLTexture', 'WebGLUniformLocation', 'WebGLVertexArrayObject'];\n\nfunction saveToWebGLVarMap(ctx, result) {\n  if (!(result === null || result === void 0 ? void 0 : result.constructor)) return;\n  var name = result.constructor.name;\n  if (!WebGLVariableConstructorsNames.includes(name)) return;\n  var variables = variableListFor(ctx, name);\n  if (!variables.includes(result)) variables.push(result);\n}\n\nfunction deserializeArg(imageMap, ctx) {\n  return function (arg) {\n    if (arg && typeof arg === 'object' && 'rr_type' in arg) {\n      if ('index' in arg) {\n        var name_1 = arg.rr_type,\n            index = arg.index;\n        return variableListFor(ctx, name_1)[index];\n      } else if ('args' in arg) {\n        var name_2 = arg.rr_type,\n            args = arg.args;\n        var ctor = window[name_2];\n        return new (ctor.bind.apply(ctor, __spreadArray([void 0], __read(args.map(deserializeArg(imageMap, ctx))), false)))();\n      } else if ('base64' in arg) {\n        return decode(arg.base64);\n      } else if ('src' in arg) {\n        var image = imageMap.get(arg.src);\n\n        if (image) {\n          return image;\n        } else {\n          var image_1 = new Image();\n          image_1.src = arg.src;\n          imageMap.set(arg.src, image_1);\n          return image_1;\n        }\n      }\n    } else if (Array.isArray(arg)) {\n      return arg.map(deserializeArg(imageMap, ctx));\n    }\n\n    return arg;\n  };\n}\n\nfunction webglMutation(_a) {\n  var mutation = _a.mutation,\n      target = _a.target,\n      type = _a.type,\n      imageMap = _a.imageMap,\n      errorHandler = _a.errorHandler;\n\n  try {\n    var ctx = getContext(target, type);\n    if (!ctx) return;\n\n    if (mutation.setter) {\n      ctx[mutation.property] = mutation.args[0];\n      return;\n    }\n\n    var original = ctx[mutation.property];\n    var args = mutation.args.map(deserializeArg(imageMap, ctx));\n    var result = original.apply(ctx, args);\n    saveToWebGLVarMap(ctx, result);\n    var debugMode = false;\n\n    if (debugMode) {\n      if (mutation.property === 'compileShader') {\n        if (!ctx.getShaderParameter(args[0], ctx.COMPILE_STATUS)) console.warn('something went wrong in replay', ctx.getShaderInfoLog(args[0]));\n      } else if (mutation.property === 'linkProgram') {\n        ctx.validateProgram(args[0]);\n        if (!ctx.getProgramParameter(args[0], ctx.LINK_STATUS)) console.warn('something went wrong in replay', ctx.getProgramInfoLog(args[0]));\n      }\n\n      var webglError = ctx.getError();\n\n      if (webglError !== ctx.NO_ERROR) {\n        console.warn.apply(console, __spreadArray(['WEBGL ERROR', webglError, 'on command:', mutation.property], __read(args), false));\n      }\n    }\n  } catch (error) {\n    errorHandler(mutation, error);\n  }\n}\n\nexport default webglMutation;\nexport { deserializeArg, variableListFor };","map":null,"metadata":{},"sourceType":"module"}