{"ast":null,"code":"import { __values } from '../ext/tslib/tslib.es6.js';\nimport { IncrementalSource } from './types.js';\nimport { IGNORED_NODE, isShadowRoot, NodeType } from '../../rrweb-snapshot/es/rrweb-snapshot.js';\n\nfunction on(type, fn, target) {\n  if (target === void 0) {\n    target = document;\n  }\n\n  var options = {\n    capture: true,\n    passive: true\n  };\n  target.addEventListener(type, fn, options);\n  return function () {\n    return target.removeEventListener(type, fn, options);\n  };\n}\n\nfunction createMirror() {\n  return {\n    map: {},\n    getId: function getId(n) {\n      if (!n || !n.__sn) {\n        return -1;\n      }\n\n      return n.__sn.id;\n    },\n    getNode: function getNode(id) {\n      return this.map[id] || null;\n    },\n    removeNodeFromMap: function removeNodeFromMap(n) {\n      var _this = this;\n\n      var id = n.__sn && n.__sn.id;\n      delete this.map[id];\n\n      if (n.childNodes) {\n        n.childNodes.forEach(function (child) {\n          return _this.removeNodeFromMap(child);\n        });\n      }\n    },\n    has: function has(id) {\n      return this.map.hasOwnProperty(id);\n    },\n    reset: function reset() {\n      this.map = {};\n    }\n  };\n}\n\nvar DEPARTED_MIRROR_ACCESS_WARNING = 'Please stop import mirror directly. Instead of that,' + '\\r\\n' + 'now you can use replayer.getMirror() to access the mirror instance of a replayer,' + '\\r\\n' + 'or you can use record.mirror to access the mirror instance during recording.';\nvar _mirror = {\n  map: {},\n  getId: function getId() {\n    console.error(DEPARTED_MIRROR_ACCESS_WARNING);\n    return -1;\n  },\n  getNode: function getNode() {\n    console.error(DEPARTED_MIRROR_ACCESS_WARNING);\n    return null;\n  },\n  removeNodeFromMap: function removeNodeFromMap() {\n    console.error(DEPARTED_MIRROR_ACCESS_WARNING);\n  },\n  has: function has() {\n    console.error(DEPARTED_MIRROR_ACCESS_WARNING);\n    return false;\n  },\n  reset: function reset() {\n    console.error(DEPARTED_MIRROR_ACCESS_WARNING);\n  }\n};\n\nif (typeof window !== 'undefined' && window.Proxy && window.Reflect) {\n  _mirror = new Proxy(_mirror, {\n    get: function get(target, prop, receiver) {\n      if (prop === 'map') {\n        console.error(DEPARTED_MIRROR_ACCESS_WARNING);\n      }\n\n      return Reflect.get(target, prop, receiver);\n    }\n  });\n}\n\nfunction throttle(func, wait, options) {\n  if (options === void 0) {\n    options = {};\n  }\n\n  var timeout = null;\n  var previous = 0;\n  return function (arg) {\n    var now = Date.now();\n\n    if (!previous && options.leading === false) {\n      previous = now;\n    }\n\n    var remaining = wait - (now - previous);\n    var context = this;\n    var args = arguments;\n\n    if (remaining <= 0 || remaining > wait) {\n      if (timeout) {\n        clearTimeout(timeout);\n        timeout = null;\n      }\n\n      previous = now;\n      func.apply(context, args);\n    } else if (!timeout && options.trailing !== false) {\n      timeout = setTimeout(function () {\n        previous = options.leading === false ? 0 : Date.now();\n        timeout = null;\n        func.apply(context, args);\n      }, remaining);\n    }\n  };\n}\n\nfunction hookSetter(target, key, d, isRevoked, win) {\n  if (win === void 0) {\n    win = window;\n  }\n\n  var original = win.Object.getOwnPropertyDescriptor(target, key);\n  win.Object.defineProperty(target, key, isRevoked ? d : {\n    set: function set(value) {\n      var _this = this;\n\n      setTimeout(function () {\n        d.set.call(_this, value);\n      }, 0);\n\n      if (original && original.set) {\n        original.set.call(this, value);\n      }\n    }\n  });\n  return function () {\n    return hookSetter(target, key, original || {}, true);\n  };\n}\n\nfunction patch(source, name, replacement) {\n  try {\n    if (!(name in source)) {\n      return function () {};\n    }\n\n    var original_1 = source[name];\n    var wrapped = replacement(original_1);\n\n    if (typeof wrapped === 'function') {\n      wrapped.prototype = wrapped.prototype || {};\n      Object.defineProperties(wrapped, {\n        __rrweb_original__: {\n          enumerable: false,\n          value: original_1\n        }\n      });\n    }\n\n    source[name] = wrapped;\n    return function () {\n      source[name] = original_1;\n    };\n  } catch (_a) {\n    return function () {};\n  }\n}\n\nfunction getWindowHeight() {\n  return window.innerHeight || document.documentElement && document.documentElement.clientHeight || document.body && document.body.clientHeight;\n}\n\nfunction getWindowWidth() {\n  return window.innerWidth || document.documentElement && document.documentElement.clientWidth || document.body && document.body.clientWidth;\n}\n\nfunction isBlocked(node, blockClass) {\n  if (!node) {\n    return false;\n  }\n\n  if (node.nodeType === node.ELEMENT_NODE) {\n    var needBlock_1 = false;\n\n    if (typeof blockClass === 'string') {\n      if (node.closest !== undefined) {\n        return node.closest('.' + blockClass) !== null;\n      } else {\n        needBlock_1 = node.classList.contains(blockClass);\n      }\n    } else {\n      node.classList.forEach(function (className) {\n        if (blockClass.test(className)) {\n          needBlock_1 = true;\n        }\n      });\n    }\n\n    return needBlock_1 || isBlocked(node.parentNode, blockClass);\n  }\n\n  if (node.nodeType === node.TEXT_NODE) {\n    return isBlocked(node.parentNode, blockClass);\n  }\n\n  return isBlocked(node.parentNode, blockClass);\n}\n\nfunction isIgnored(n) {\n  if ('__sn' in n) {\n    return n.__sn.id === IGNORED_NODE;\n  }\n\n  return false;\n}\n\nfunction isAncestorRemoved(target, mirror) {\n  if (isShadowRoot(target)) {\n    return false;\n  }\n\n  var id = mirror.getId(target);\n\n  if (!mirror.has(id)) {\n    return true;\n  }\n\n  if (target.parentNode && target.parentNode.nodeType === target.DOCUMENT_NODE) {\n    return false;\n  }\n\n  if (!target.parentNode) {\n    return true;\n  }\n\n  return isAncestorRemoved(target.parentNode, mirror);\n}\n\nfunction isTouchEvent(event) {\n  return Boolean(event.changedTouches);\n}\n\nfunction polyfill(win) {\n  if (win === void 0) {\n    win = window;\n  }\n\n  if ('NodeList' in win && !win.NodeList.prototype.forEach) {\n    win.NodeList.prototype.forEach = Array.prototype.forEach;\n  }\n\n  if ('DOMTokenList' in win && !win.DOMTokenList.prototype.forEach) {\n    win.DOMTokenList.prototype.forEach = Array.prototype.forEach;\n  }\n\n  if (!Node.prototype.contains) {\n    Node.prototype.contains = function contains(node) {\n      if (!(0 in arguments)) {\n        throw new TypeError('1 argument is required');\n      }\n\n      do {\n        if (this === node) {\n          return true;\n        }\n      } while (node = node && node.parentNode);\n\n      return false;\n    };\n  }\n}\n\nvar TreeIndex = function () {\n  function TreeIndex() {\n    this.reset();\n  }\n\n  TreeIndex.prototype.add = function (mutation) {\n    var parentTreeNode = this.indexes.get(mutation.parentId);\n    var treeNode = {\n      id: mutation.node.id,\n      mutation: mutation,\n      children: [],\n      texts: [],\n      attributes: []\n    };\n\n    if (!parentTreeNode) {\n      this.tree[treeNode.id] = treeNode;\n    } else {\n      treeNode.parent = parentTreeNode;\n      parentTreeNode.children[treeNode.id] = treeNode;\n    }\n\n    this.indexes.set(treeNode.id, treeNode);\n  };\n\n  TreeIndex.prototype.remove = function (mutation, mirror) {\n    var _this = this;\n\n    var parentTreeNode = this.indexes.get(mutation.parentId);\n    var treeNode = this.indexes.get(mutation.id);\n\n    var deepRemoveFromMirror = function deepRemoveFromMirror(id) {\n      _this.removeIdSet.add(id);\n\n      var node = mirror.getNode(id);\n      node === null || node === void 0 ? void 0 : node.childNodes.forEach(function (childNode) {\n        if ('__sn' in childNode) {\n          deepRemoveFromMirror(childNode.__sn.id);\n        }\n      });\n    };\n\n    var deepRemoveFromTreeIndex = function deepRemoveFromTreeIndex(node) {\n      _this.removeIdSet.add(node.id);\n\n      Object.values(node.children).forEach(function (n) {\n        return deepRemoveFromTreeIndex(n);\n      });\n\n      var _treeNode = _this.indexes.get(node.id);\n\n      if (_treeNode) {\n        var _parentTreeNode = _treeNode.parent;\n\n        if (_parentTreeNode) {\n          delete _treeNode.parent;\n          delete _parentTreeNode.children[_treeNode.id];\n\n          _this.indexes.delete(mutation.id);\n        }\n      }\n    };\n\n    if (!treeNode) {\n      this.removeNodeMutations.push(mutation);\n      deepRemoveFromMirror(mutation.id);\n    } else if (!parentTreeNode) {\n      delete this.tree[treeNode.id];\n      this.indexes.delete(treeNode.id);\n      deepRemoveFromTreeIndex(treeNode);\n    } else {\n      delete treeNode.parent;\n      delete parentTreeNode.children[treeNode.id];\n      this.indexes.delete(mutation.id);\n      deepRemoveFromTreeIndex(treeNode);\n    }\n  };\n\n  TreeIndex.prototype.text = function (mutation) {\n    var treeNode = this.indexes.get(mutation.id);\n\n    if (treeNode) {\n      treeNode.texts.push(mutation);\n    } else {\n      this.textMutations.push(mutation);\n    }\n  };\n\n  TreeIndex.prototype.attribute = function (mutation) {\n    var treeNode = this.indexes.get(mutation.id);\n\n    if (treeNode) {\n      treeNode.attributes.push(mutation);\n    } else {\n      this.attributeMutations.push(mutation);\n    }\n  };\n\n  TreeIndex.prototype.scroll = function (d) {\n    this.scrollMap.set(d.id, d);\n  };\n\n  TreeIndex.prototype.input = function (d) {\n    this.inputMap.set(d.id, d);\n  };\n\n  TreeIndex.prototype.flush = function () {\n    var e_1, _a, e_2, _b;\n\n    var _this = this;\n\n    var _c = this,\n        tree = _c.tree,\n        removeNodeMutations = _c.removeNodeMutations,\n        textMutations = _c.textMutations,\n        attributeMutations = _c.attributeMutations;\n\n    var batchMutationData = {\n      source: IncrementalSource.Mutation,\n      removes: removeNodeMutations,\n      texts: textMutations,\n      attributes: attributeMutations,\n      adds: []\n    };\n\n    var walk = function walk(treeNode, removed) {\n      if (removed) {\n        _this.removeIdSet.add(treeNode.id);\n      }\n\n      batchMutationData.texts = batchMutationData.texts.concat(removed ? [] : treeNode.texts).filter(function (m) {\n        return !_this.removeIdSet.has(m.id);\n      });\n      batchMutationData.attributes = batchMutationData.attributes.concat(removed ? [] : treeNode.attributes).filter(function (m) {\n        return !_this.removeIdSet.has(m.id);\n      });\n\n      if (!_this.removeIdSet.has(treeNode.id) && !_this.removeIdSet.has(treeNode.mutation.parentId) && !removed) {\n        batchMutationData.adds.push(treeNode.mutation);\n\n        if (treeNode.children) {\n          Object.values(treeNode.children).forEach(function (n) {\n            return walk(n, false);\n          });\n        }\n      } else {\n        Object.values(treeNode.children).forEach(function (n) {\n          return walk(n, true);\n        });\n      }\n    };\n\n    Object.values(tree).forEach(function (n) {\n      return walk(n, false);\n    });\n\n    try {\n      for (var _d = __values(this.scrollMap.keys()), _e = _d.next(); !_e.done; _e = _d.next()) {\n        var id = _e.value;\n\n        if (this.removeIdSet.has(id)) {\n          this.scrollMap.delete(id);\n        }\n      }\n    } catch (e_1_1) {\n      e_1 = {\n        error: e_1_1\n      };\n    } finally {\n      try {\n        if (_e && !_e.done && (_a = _d.return)) _a.call(_d);\n      } finally {\n        if (e_1) throw e_1.error;\n      }\n    }\n\n    try {\n      for (var _f = __values(this.inputMap.keys()), _g = _f.next(); !_g.done; _g = _f.next()) {\n        var id = _g.value;\n\n        if (this.removeIdSet.has(id)) {\n          this.inputMap.delete(id);\n        }\n      }\n    } catch (e_2_1) {\n      e_2 = {\n        error: e_2_1\n      };\n    } finally {\n      try {\n        if (_g && !_g.done && (_b = _f.return)) _b.call(_f);\n      } finally {\n        if (e_2) throw e_2.error;\n      }\n    }\n\n    var scrollMap = new Map(this.scrollMap);\n    var inputMap = new Map(this.inputMap);\n    this.reset();\n    return {\n      mutationData: batchMutationData,\n      scrollMap: scrollMap,\n      inputMap: inputMap\n    };\n  };\n\n  TreeIndex.prototype.reset = function () {\n    this.tree = [];\n    this.indexes = new Map();\n    this.removeNodeMutations = [];\n    this.textMutations = [];\n    this.attributeMutations = [];\n    this.removeIdSet = new Set();\n    this.scrollMap = new Map();\n    this.inputMap = new Map();\n  };\n\n  TreeIndex.prototype.idRemoved = function (id) {\n    return this.removeIdSet.has(id);\n  };\n\n  return TreeIndex;\n}();\n\nfunction queueToResolveTrees(queue) {\n  var e_3, _a;\n\n  var queueNodeMap = {};\n\n  var putIntoMap = function putIntoMap(m, parent) {\n    var nodeInTree = {\n      value: m,\n      parent: parent,\n      children: []\n    };\n    queueNodeMap[m.node.id] = nodeInTree;\n    return nodeInTree;\n  };\n\n  var queueNodeTrees = [];\n\n  try {\n    for (var queue_1 = __values(queue), queue_1_1 = queue_1.next(); !queue_1_1.done; queue_1_1 = queue_1.next()) {\n      var mutation = queue_1_1.value;\n      var nextId = mutation.nextId,\n          parentId = mutation.parentId;\n\n      if (nextId && nextId in queueNodeMap) {\n        var nextInTree = queueNodeMap[nextId];\n\n        if (nextInTree.parent) {\n          var idx = nextInTree.parent.children.indexOf(nextInTree);\n          nextInTree.parent.children.splice(idx, 0, putIntoMap(mutation, nextInTree.parent));\n        } else {\n          var idx = queueNodeTrees.indexOf(nextInTree);\n          queueNodeTrees.splice(idx, 0, putIntoMap(mutation, null));\n        }\n\n        continue;\n      }\n\n      if (parentId in queueNodeMap) {\n        var parentInTree = queueNodeMap[parentId];\n        parentInTree.children.push(putIntoMap(mutation, parentInTree));\n        continue;\n      }\n\n      queueNodeTrees.push(putIntoMap(mutation, null));\n    }\n  } catch (e_3_1) {\n    e_3 = {\n      error: e_3_1\n    };\n  } finally {\n    try {\n      if (queue_1_1 && !queue_1_1.done && (_a = queue_1.return)) _a.call(queue_1);\n    } finally {\n      if (e_3) throw e_3.error;\n    }\n  }\n\n  return queueNodeTrees;\n}\n\nfunction iterateResolveTree(tree, cb) {\n  cb(tree.value);\n\n  for (var i = tree.children.length - 1; i >= 0; i--) {\n    iterateResolveTree(tree.children[i], cb);\n  }\n}\n\nfunction isIframeINode(node) {\n  if ('__sn' in node) {\n    return node.__sn.type === NodeType.Element && node.__sn.tagName === 'iframe';\n  }\n\n  return false;\n}\n\nfunction getBaseDimension(node, rootIframe) {\n  var _a, _b;\n\n  var frameElement = (_b = (_a = node.ownerDocument) === null || _a === void 0 ? void 0 : _a.defaultView) === null || _b === void 0 ? void 0 : _b.frameElement;\n\n  if (!frameElement || frameElement === rootIframe) {\n    return {\n      x: 0,\n      y: 0,\n      relativeScale: 1,\n      absoluteScale: 1\n    };\n  }\n\n  var frameDimension = frameElement.getBoundingClientRect();\n  var frameBaseDimension = getBaseDimension(frameElement, rootIframe);\n  var relativeScale = frameDimension.height / frameElement.clientHeight;\n  return {\n    x: frameDimension.x * frameBaseDimension.relativeScale + frameBaseDimension.x,\n    y: frameDimension.y * frameBaseDimension.relativeScale + frameBaseDimension.y,\n    relativeScale: relativeScale,\n    absoluteScale: frameBaseDimension.absoluteScale * relativeScale\n  };\n}\n\nfunction hasShadowRoot(n) {\n  return Boolean(n === null || n === void 0 ? void 0 : n.shadowRoot);\n}\n\nexport { TreeIndex, _mirror, createMirror, getBaseDimension, getWindowHeight, getWindowWidth, hasShadowRoot, hookSetter, isAncestorRemoved, isBlocked, isIframeINode, isIgnored, isTouchEvent, iterateResolveTree, on, patch, polyfill, queueToResolveTrees, throttle };","map":null,"metadata":{},"sourceType":"module"}