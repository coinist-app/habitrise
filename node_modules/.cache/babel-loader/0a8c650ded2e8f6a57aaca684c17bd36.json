{"ast":null,"code":"import { __read, __values, __spreadArray, __assign } from '../../ext/tslib/tslib.es6.js';\nimport { maskInputValue } from '../../../rrweb-snapshot/es/rrweb-snapshot.js';\nimport { on, throttle, isTouchEvent, isBlocked, getWindowHeight, getWindowWidth, hookSetter, patch } from '../utils.js';\nimport { IncrementalSource, MouseInteractions } from '../types.js';\nimport MutationBuffer from './mutation.js';\nvar mutationBuffers = [];\nvar isCSSGroupingRuleSupported = typeof CSSGroupingRule !== 'undefined';\nvar isCSSMediaRuleSupported = typeof CSSMediaRule !== 'undefined';\nvar isCSSSupportsRuleSupported = typeof CSSSupportsRule !== 'undefined';\nvar isCSSConditionRuleSupported = typeof CSSConditionRule !== 'undefined';\n\nfunction getEventTarget(event) {\n  try {\n    if ('composedPath' in event) {\n      var path = event.composedPath();\n\n      if (path.length) {\n        return path[0];\n      }\n    } else if ('path' in event && event.path.length) {\n      return event.path[0];\n    }\n\n    return event.target;\n  } catch (_a) {\n    return event.target;\n  }\n}\n\nfunction initMutationObserver(options, rootEl) {\n  var _a, _b;\n\n  var mutationBuffer = new MutationBuffer();\n  mutationBuffers.push(mutationBuffer);\n  mutationBuffer.init(options);\n  var mutationObserverCtor = window.MutationObserver || window.__rrMutationObserver;\n  var angularZoneSymbol = (_b = (_a = window === null || window === void 0 ? void 0 : window.Zone) === null || _a === void 0 ? void 0 : _a.__symbol__) === null || _b === void 0 ? void 0 : _b.call(_a, 'MutationObserver');\n\n  if (angularZoneSymbol && window[angularZoneSymbol]) {\n    mutationObserverCtor = window[angularZoneSymbol];\n  }\n\n  var observer = new mutationObserverCtor(mutationBuffer.processMutations.bind(mutationBuffer));\n  observer.observe(rootEl, {\n    attributes: true,\n    attributeOldValue: true,\n    characterData: true,\n    characterDataOldValue: true,\n    childList: true,\n    subtree: true\n  });\n  return observer;\n}\n\nfunction initMoveObserver(_a) {\n  var mousemoveCb = _a.mousemoveCb,\n      sampling = _a.sampling,\n      doc = _a.doc,\n      mirror = _a.mirror;\n\n  if (sampling.mousemove === false) {\n    return function () {};\n  }\n\n  var threshold = typeof sampling.mousemove === 'number' ? sampling.mousemove : 50;\n  var callbackThreshold = typeof sampling.mousemoveCallback === 'number' ? sampling.mousemoveCallback : 500;\n  var positions = [];\n  var timeBaseline;\n  var wrappedCb = throttle(function (source) {\n    var totalOffset = Date.now() - timeBaseline;\n    mousemoveCb(positions.map(function (p) {\n      p.timeOffset -= totalOffset;\n      return p;\n    }), source);\n    positions = [];\n    timeBaseline = null;\n  }, callbackThreshold);\n  var updatePosition = throttle(function (evt) {\n    var target = getEventTarget(evt);\n\n    var _a = isTouchEvent(evt) ? evt.changedTouches[0] : evt,\n        clientX = _a.clientX,\n        clientY = _a.clientY;\n\n    if (!timeBaseline) {\n      timeBaseline = Date.now();\n    }\n\n    positions.push({\n      x: clientX,\n      y: clientY,\n      id: mirror.getId(target),\n      timeOffset: Date.now() - timeBaseline\n    });\n    wrappedCb(typeof DragEvent !== 'undefined' && evt instanceof DragEvent ? IncrementalSource.Drag : evt instanceof MouseEvent ? IncrementalSource.MouseMove : IncrementalSource.TouchMove);\n  }, threshold, {\n    trailing: false\n  });\n  var handlers = [on('mousemove', updatePosition, doc), on('touchmove', updatePosition, doc), on('drag', updatePosition, doc)];\n  return function () {\n    handlers.forEach(function (h) {\n      return h();\n    });\n  };\n}\n\nfunction initMouseInteractionObserver(_a) {\n  var mouseInteractionCb = _a.mouseInteractionCb,\n      doc = _a.doc,\n      mirror = _a.mirror,\n      blockClass = _a.blockClass,\n      sampling = _a.sampling;\n\n  if (sampling.mouseInteraction === false) {\n    return function () {};\n  }\n\n  var disableMap = sampling.mouseInteraction === true || sampling.mouseInteraction === undefined ? {} : sampling.mouseInteraction;\n  var handlers = [];\n\n  var getHandler = function getHandler(eventKey) {\n    return function (event) {\n      var target = getEventTarget(event);\n\n      if (isBlocked(target, blockClass)) {\n        return;\n      }\n\n      var e = isTouchEvent(event) ? event.changedTouches[0] : event;\n\n      if (!e) {\n        return;\n      }\n\n      var id = mirror.getId(target);\n      var clientX = e.clientX,\n          clientY = e.clientY;\n      mouseInteractionCb({\n        type: MouseInteractions[eventKey],\n        id: id,\n        x: clientX,\n        y: clientY\n      });\n    };\n  };\n\n  Object.keys(MouseInteractions).filter(function (key) {\n    return Number.isNaN(Number(key)) && !key.endsWith('_Departed') && disableMap[key] !== false;\n  }).forEach(function (eventKey) {\n    var eventName = eventKey.toLowerCase();\n    var handler = getHandler(eventKey);\n    handlers.push(on(eventName, handler, doc));\n  });\n  return function () {\n    handlers.forEach(function (h) {\n      return h();\n    });\n  };\n}\n\nfunction initScrollObserver(_a) {\n  var scrollCb = _a.scrollCb,\n      doc = _a.doc,\n      mirror = _a.mirror,\n      blockClass = _a.blockClass,\n      sampling = _a.sampling;\n  var updatePosition = throttle(function (evt) {\n    var target = getEventTarget(evt);\n\n    if (!target || isBlocked(target, blockClass)) {\n      return;\n    }\n\n    var id = mirror.getId(target);\n\n    if (target === doc) {\n      var scrollEl = doc.scrollingElement || doc.documentElement;\n      scrollCb({\n        id: id,\n        x: scrollEl.scrollLeft,\n        y: scrollEl.scrollTop\n      });\n    } else {\n      scrollCb({\n        id: id,\n        x: target.scrollLeft,\n        y: target.scrollTop\n      });\n    }\n  }, sampling.scroll || 100);\n  return on('scroll', updatePosition, doc);\n}\n\nfunction initViewportResizeObserver(_a) {\n  var viewportResizeCb = _a.viewportResizeCb;\n  var lastH = -1;\n  var lastW = -1;\n  var updateDimension = throttle(function () {\n    var height = getWindowHeight();\n    var width = getWindowWidth();\n\n    if (lastH !== height || lastW !== width) {\n      viewportResizeCb({\n        width: Number(width),\n        height: Number(height)\n      });\n      lastH = height;\n      lastW = width;\n    }\n  }, 200);\n  return on('resize', updateDimension, window);\n}\n\nfunction wrapEventWithUserTriggeredFlag(v, enable) {\n  var value = __assign({}, v);\n\n  if (!enable) delete value.userTriggered;\n  return value;\n}\n\nvar INPUT_TAGS = ['INPUT', 'TEXTAREA', 'SELECT'];\nvar lastInputValueMap = new WeakMap();\n\nfunction initInputObserver(_a) {\n  var inputCb = _a.inputCb,\n      doc = _a.doc,\n      mirror = _a.mirror,\n      blockClass = _a.blockClass,\n      ignoreClass = _a.ignoreClass,\n      maskInputOptions = _a.maskInputOptions,\n      maskInputFn = _a.maskInputFn,\n      sampling = _a.sampling,\n      userTriggeredOnInput = _a.userTriggeredOnInput;\n\n  function eventHandler(event) {\n    var target = getEventTarget(event);\n    var userTriggered = event.isTrusted;\n    if (target && target.tagName === 'OPTION') target = target.parentElement;\n\n    if (!target || !target.tagName || INPUT_TAGS.indexOf(target.tagName) < 0 || isBlocked(target, blockClass)) {\n      return;\n    }\n\n    var type = target.type;\n\n    if (target.classList.contains(ignoreClass)) {\n      return;\n    }\n\n    var text = target.value;\n    var isChecked = false;\n\n    if (type === 'radio' || type === 'checkbox') {\n      isChecked = target.checked;\n    } else if (maskInputOptions[target.tagName.toLowerCase()] || maskInputOptions[type]) {\n      text = maskInputValue({\n        maskInputOptions: maskInputOptions,\n        tagName: target.tagName,\n        type: type,\n        value: text,\n        maskInputFn: maskInputFn\n      });\n    }\n\n    cbWithDedup(target, wrapEventWithUserTriggeredFlag({\n      text: text,\n      isChecked: isChecked,\n      userTriggered: userTriggered\n    }, userTriggeredOnInput));\n    var name = target.name;\n\n    if (type === 'radio' && name && isChecked) {\n      doc.querySelectorAll(\"input[type=\\\"radio\\\"][name=\\\"\".concat(name, \"\\\"]\")).forEach(function (el) {\n        if (el !== target) {\n          cbWithDedup(el, wrapEventWithUserTriggeredFlag({\n            text: el.value,\n            isChecked: !isChecked,\n            userTriggered: false\n          }, userTriggeredOnInput));\n        }\n      });\n    }\n  }\n\n  function cbWithDedup(target, v) {\n    var lastInputValue = lastInputValueMap.get(target);\n\n    if (!lastInputValue || lastInputValue.text !== v.text || lastInputValue.isChecked !== v.isChecked) {\n      lastInputValueMap.set(target, v);\n      var id = mirror.getId(target);\n      inputCb(__assign(__assign({}, v), {\n        id: id\n      }));\n    }\n  }\n\n  var events = sampling.input === 'last' ? ['change'] : ['input', 'change'];\n  var handlers = events.map(function (eventName) {\n    return on(eventName, eventHandler, doc);\n  });\n  var propertyDescriptor = Object.getOwnPropertyDescriptor(HTMLInputElement.prototype, 'value');\n  var hookProperties = [[HTMLInputElement.prototype, 'value'], [HTMLInputElement.prototype, 'checked'], [HTMLSelectElement.prototype, 'value'], [HTMLTextAreaElement.prototype, 'value'], [HTMLSelectElement.prototype, 'selectedIndex'], [HTMLOptionElement.prototype, 'selected']];\n\n  if (propertyDescriptor && propertyDescriptor.set) {\n    handlers.push.apply(handlers, __spreadArray([], __read(hookProperties.map(function (p) {\n      return hookSetter(p[0], p[1], {\n        set: function set() {\n          eventHandler({\n            target: this\n          });\n        }\n      });\n    })), false));\n  }\n\n  return function () {\n    handlers.forEach(function (h) {\n      return h();\n    });\n  };\n}\n\nfunction getNestedCSSRulePositions(rule) {\n  var positions = [];\n\n  function recurse(childRule, pos) {\n    if (isCSSGroupingRuleSupported && childRule.parentRule instanceof CSSGroupingRule || isCSSMediaRuleSupported && childRule.parentRule instanceof CSSMediaRule || isCSSSupportsRuleSupported && childRule.parentRule instanceof CSSSupportsRule || isCSSConditionRuleSupported && childRule.parentRule instanceof CSSConditionRule) {\n      var rules = Array.from(childRule.parentRule.cssRules);\n      var index = rules.indexOf(childRule);\n      pos.unshift(index);\n    } else {\n      var rules = Array.from(childRule.parentStyleSheet.cssRules);\n      var index = rules.indexOf(childRule);\n      pos.unshift(index);\n    }\n\n    return pos;\n  }\n\n  return recurse(rule, positions);\n}\n\nfunction initStyleSheetObserver(_a, _b) {\n  var styleSheetRuleCb = _a.styleSheetRuleCb,\n      mirror = _a.mirror;\n  var win = _b.win;\n  var insertRule = win.CSSStyleSheet.prototype.insertRule;\n\n  win.CSSStyleSheet.prototype.insertRule = function (rule, index) {\n    var id = mirror.getId(this.ownerNode);\n\n    if (id !== -1) {\n      styleSheetRuleCb({\n        id: id,\n        adds: [{\n          rule: rule,\n          index: index\n        }]\n      });\n    }\n\n    return insertRule.apply(this, arguments);\n  };\n\n  var deleteRule = win.CSSStyleSheet.prototype.deleteRule;\n\n  win.CSSStyleSheet.prototype.deleteRule = function (index) {\n    var id = mirror.getId(this.ownerNode);\n\n    if (id !== -1) {\n      styleSheetRuleCb({\n        id: id,\n        removes: [{\n          index: index\n        }]\n      });\n    }\n\n    return deleteRule.apply(this, arguments);\n  };\n\n  var supportedNestedCSSRuleTypes = {};\n\n  if (isCSSGroupingRuleSupported) {\n    supportedNestedCSSRuleTypes.CSSGroupingRule = win.CSSGroupingRule;\n  } else {\n    if (isCSSMediaRuleSupported) {\n      supportedNestedCSSRuleTypes.CSSMediaRule = win.CSSMediaRule;\n    }\n\n    if (isCSSConditionRuleSupported) {\n      supportedNestedCSSRuleTypes.CSSConditionRule = win.CSSConditionRule;\n    }\n\n    if (isCSSSupportsRuleSupported) {\n      supportedNestedCSSRuleTypes.CSSSupportsRule = win.CSSSupportsRule;\n    }\n  }\n\n  var unmodifiedFunctions = {};\n  Object.entries(supportedNestedCSSRuleTypes).forEach(function (_a) {\n    var _b = __read(_a, 2),\n        typeKey = _b[0],\n        type = _b[1];\n\n    unmodifiedFunctions[typeKey] = {\n      insertRule: type.prototype.insertRule,\n      deleteRule: type.prototype.deleteRule\n    };\n\n    type.prototype.insertRule = function (rule, index) {\n      var id = mirror.getId(this.parentStyleSheet.ownerNode);\n\n      if (id !== -1) {\n        styleSheetRuleCb({\n          id: id,\n          adds: [{\n            rule: rule,\n            index: __spreadArray(__spreadArray([], __read(getNestedCSSRulePositions(this)), false), [index || 0], false)\n          }]\n        });\n      }\n\n      return unmodifiedFunctions[typeKey].insertRule.apply(this, arguments);\n    };\n\n    type.prototype.deleteRule = function (index) {\n      var id = mirror.getId(this.parentStyleSheet.ownerNode);\n\n      if (id !== -1) {\n        styleSheetRuleCb({\n          id: id,\n          removes: [{\n            index: __spreadArray(__spreadArray([], __read(getNestedCSSRulePositions(this)), false), [index], false)\n          }]\n        });\n      }\n\n      return unmodifiedFunctions[typeKey].deleteRule.apply(this, arguments);\n    };\n  });\n  return function () {\n    win.CSSStyleSheet.prototype.insertRule = insertRule;\n    win.CSSStyleSheet.prototype.deleteRule = deleteRule;\n    Object.entries(supportedNestedCSSRuleTypes).forEach(function (_a) {\n      var _b = __read(_a, 2),\n          typeKey = _b[0],\n          type = _b[1];\n\n      type.prototype.insertRule = unmodifiedFunctions[typeKey].insertRule;\n      type.prototype.deleteRule = unmodifiedFunctions[typeKey].deleteRule;\n    });\n  };\n}\n\nfunction initStyleDeclarationObserver(_a, _b) {\n  var styleDeclarationCb = _a.styleDeclarationCb,\n      mirror = _a.mirror;\n  var win = _b.win;\n  var setProperty = win.CSSStyleDeclaration.prototype.setProperty;\n\n  win.CSSStyleDeclaration.prototype.setProperty = function (property, value, priority) {\n    var _a, _b;\n\n    var id = mirror.getId((_b = (_a = this.parentRule) === null || _a === void 0 ? void 0 : _a.parentStyleSheet) === null || _b === void 0 ? void 0 : _b.ownerNode);\n\n    if (id !== -1) {\n      styleDeclarationCb({\n        id: id,\n        set: {\n          property: property,\n          value: value,\n          priority: priority\n        },\n        index: getNestedCSSRulePositions(this.parentRule)\n      });\n    }\n\n    return setProperty.apply(this, arguments);\n  };\n\n  var removeProperty = win.CSSStyleDeclaration.prototype.removeProperty;\n\n  win.CSSStyleDeclaration.prototype.removeProperty = function (property) {\n    var _a, _b;\n\n    var id = mirror.getId((_b = (_a = this.parentRule) === null || _a === void 0 ? void 0 : _a.parentStyleSheet) === null || _b === void 0 ? void 0 : _b.ownerNode);\n\n    if (id !== -1) {\n      styleDeclarationCb({\n        id: id,\n        remove: {\n          property: property\n        },\n        index: getNestedCSSRulePositions(this.parentRule)\n      });\n    }\n\n    return removeProperty.apply(this, arguments);\n  };\n\n  return function () {\n    win.CSSStyleDeclaration.prototype.setProperty = setProperty;\n    win.CSSStyleDeclaration.prototype.removeProperty = removeProperty;\n  };\n}\n\nfunction initMediaInteractionObserver(_a) {\n  var mediaInteractionCb = _a.mediaInteractionCb,\n      blockClass = _a.blockClass,\n      mirror = _a.mirror,\n      sampling = _a.sampling;\n\n  var handler = function handler(type) {\n    return throttle(function (event) {\n      var target = getEventTarget(event);\n\n      if (!target || isBlocked(target, blockClass)) {\n        return;\n      }\n\n      var _a = target,\n          currentTime = _a.currentTime,\n          volume = _a.volume,\n          muted = _a.muted;\n      mediaInteractionCb({\n        type: type,\n        id: mirror.getId(target),\n        currentTime: currentTime,\n        volume: volume,\n        muted: muted\n      });\n    }, sampling.media || 500);\n  };\n\n  var handlers = [on('play', handler(0)), on('pause', handler(1)), on('seeked', handler(2)), on('volumechange', handler(3))];\n  return function () {\n    handlers.forEach(function (h) {\n      return h();\n    });\n  };\n}\n\nfunction initFontObserver(_a) {\n  var fontCb = _a.fontCb,\n      doc = _a.doc;\n  var win = doc.defaultView;\n\n  if (!win) {\n    return function () {};\n  }\n\n  var handlers = [];\n  var fontMap = new WeakMap();\n  var originalFontFace = win.FontFace;\n\n  win.FontFace = function FontFace(family, source, descriptors) {\n    var fontFace = new originalFontFace(family, source, descriptors);\n    fontMap.set(fontFace, {\n      family: family,\n      buffer: typeof source !== 'string',\n      descriptors: descriptors,\n      fontSource: typeof source === 'string' ? source : JSON.stringify(Array.from(new Uint8Array(source)))\n    });\n    return fontFace;\n  };\n\n  var restoreHandler = patch(doc.fonts, 'add', function (original) {\n    return function (fontFace) {\n      setTimeout(function () {\n        var p = fontMap.get(fontFace);\n\n        if (p) {\n          fontCb(p);\n          fontMap.delete(fontFace);\n        }\n      }, 0);\n      return original.apply(this, [fontFace]);\n    };\n  });\n  handlers.push(function () {\n    win.FontFace = originalFontFace;\n  });\n  handlers.push(restoreHandler);\n  return function () {\n    handlers.forEach(function (h) {\n      return h();\n    });\n  };\n}\n\nfunction mergeHooks(o, hooks) {\n  var mutationCb = o.mutationCb,\n      mousemoveCb = o.mousemoveCb,\n      mouseInteractionCb = o.mouseInteractionCb,\n      scrollCb = o.scrollCb,\n      viewportResizeCb = o.viewportResizeCb,\n      inputCb = o.inputCb,\n      mediaInteractionCb = o.mediaInteractionCb,\n      styleSheetRuleCb = o.styleSheetRuleCb,\n      styleDeclarationCb = o.styleDeclarationCb,\n      canvasMutationCb = o.canvasMutationCb,\n      fontCb = o.fontCb;\n\n  o.mutationCb = function () {\n    var p = [];\n\n    for (var _i = 0; _i < arguments.length; _i++) {\n      p[_i] = arguments[_i];\n    }\n\n    if (hooks.mutation) {\n      hooks.mutation.apply(hooks, __spreadArray([], __read(p), false));\n    }\n\n    mutationCb.apply(void 0, __spreadArray([], __read(p), false));\n  };\n\n  o.mousemoveCb = function () {\n    var p = [];\n\n    for (var _i = 0; _i < arguments.length; _i++) {\n      p[_i] = arguments[_i];\n    }\n\n    if (hooks.mousemove) {\n      hooks.mousemove.apply(hooks, __spreadArray([], __read(p), false));\n    }\n\n    mousemoveCb.apply(void 0, __spreadArray([], __read(p), false));\n  };\n\n  o.mouseInteractionCb = function () {\n    var p = [];\n\n    for (var _i = 0; _i < arguments.length; _i++) {\n      p[_i] = arguments[_i];\n    }\n\n    if (hooks.mouseInteraction) {\n      hooks.mouseInteraction.apply(hooks, __spreadArray([], __read(p), false));\n    }\n\n    mouseInteractionCb.apply(void 0, __spreadArray([], __read(p), false));\n  };\n\n  o.scrollCb = function () {\n    var p = [];\n\n    for (var _i = 0; _i < arguments.length; _i++) {\n      p[_i] = arguments[_i];\n    }\n\n    if (hooks.scroll) {\n      hooks.scroll.apply(hooks, __spreadArray([], __read(p), false));\n    }\n\n    scrollCb.apply(void 0, __spreadArray([], __read(p), false));\n  };\n\n  o.viewportResizeCb = function () {\n    var p = [];\n\n    for (var _i = 0; _i < arguments.length; _i++) {\n      p[_i] = arguments[_i];\n    }\n\n    if (hooks.viewportResize) {\n      hooks.viewportResize.apply(hooks, __spreadArray([], __read(p), false));\n    }\n\n    viewportResizeCb.apply(void 0, __spreadArray([], __read(p), false));\n  };\n\n  o.inputCb = function () {\n    var p = [];\n\n    for (var _i = 0; _i < arguments.length; _i++) {\n      p[_i] = arguments[_i];\n    }\n\n    if (hooks.input) {\n      hooks.input.apply(hooks, __spreadArray([], __read(p), false));\n    }\n\n    inputCb.apply(void 0, __spreadArray([], __read(p), false));\n  };\n\n  o.mediaInteractionCb = function () {\n    var p = [];\n\n    for (var _i = 0; _i < arguments.length; _i++) {\n      p[_i] = arguments[_i];\n    }\n\n    if (hooks.mediaInteaction) {\n      hooks.mediaInteaction.apply(hooks, __spreadArray([], __read(p), false));\n    }\n\n    mediaInteractionCb.apply(void 0, __spreadArray([], __read(p), false));\n  };\n\n  o.styleSheetRuleCb = function () {\n    var p = [];\n\n    for (var _i = 0; _i < arguments.length; _i++) {\n      p[_i] = arguments[_i];\n    }\n\n    if (hooks.styleSheetRule) {\n      hooks.styleSheetRule.apply(hooks, __spreadArray([], __read(p), false));\n    }\n\n    styleSheetRuleCb.apply(void 0, __spreadArray([], __read(p), false));\n  };\n\n  o.styleDeclarationCb = function () {\n    var p = [];\n\n    for (var _i = 0; _i < arguments.length; _i++) {\n      p[_i] = arguments[_i];\n    }\n\n    if (hooks.styleDeclaration) {\n      hooks.styleDeclaration.apply(hooks, __spreadArray([], __read(p), false));\n    }\n\n    styleDeclarationCb.apply(void 0, __spreadArray([], __read(p), false));\n  };\n\n  o.canvasMutationCb = function () {\n    var p = [];\n\n    for (var _i = 0; _i < arguments.length; _i++) {\n      p[_i] = arguments[_i];\n    }\n\n    if (hooks.canvasMutation) {\n      hooks.canvasMutation.apply(hooks, __spreadArray([], __read(p), false));\n    }\n\n    canvasMutationCb.apply(void 0, __spreadArray([], __read(p), false));\n  };\n\n  o.fontCb = function () {\n    var p = [];\n\n    for (var _i = 0; _i < arguments.length; _i++) {\n      p[_i] = arguments[_i];\n    }\n\n    if (hooks.font) {\n      hooks.font.apply(hooks, __spreadArray([], __read(p), false));\n    }\n\n    fontCb.apply(void 0, __spreadArray([], __read(p), false));\n  };\n}\n\nfunction initObservers(o, hooks) {\n  var e_1, _a;\n\n  if (hooks === void 0) {\n    hooks = {};\n  }\n\n  var currentWindow = o.doc.defaultView;\n\n  if (!currentWindow) {\n    return function () {};\n  }\n\n  mergeHooks(o, hooks);\n  var mutationObserver = initMutationObserver(o, o.doc);\n  var mousemoveHandler = initMoveObserver(o);\n  var mouseInteractionHandler = initMouseInteractionObserver(o);\n  var scrollHandler = initScrollObserver(o);\n  var viewportResizeHandler = initViewportResizeObserver(o);\n  var inputHandler = initInputObserver(o);\n  var mediaInteractionHandler = initMediaInteractionObserver(o);\n  var styleSheetObserver = initStyleSheetObserver(o, {\n    win: currentWindow\n  });\n  var styleDeclarationObserver = initStyleDeclarationObserver(o, {\n    win: currentWindow\n  });\n  var fontObserver = o.collectFonts ? initFontObserver(o) : function () {};\n  var pluginHandlers = [];\n\n  try {\n    for (var _b = __values(o.plugins), _c = _b.next(); !_c.done; _c = _b.next()) {\n      var plugin = _c.value;\n      pluginHandlers.push(plugin.observer(plugin.callback, currentWindow, plugin.options));\n    }\n  } catch (e_1_1) {\n    e_1 = {\n      error: e_1_1\n    };\n  } finally {\n    try {\n      if (_c && !_c.done && (_a = _b.return)) _a.call(_b);\n    } finally {\n      if (e_1) throw e_1.error;\n    }\n  }\n\n  return function () {\n    mutationBuffers.forEach(function (b) {\n      return b.reset();\n    });\n    mutationObserver.disconnect();\n    mousemoveHandler();\n    mouseInteractionHandler();\n    scrollHandler();\n    viewportResizeHandler();\n    inputHandler();\n    mediaInteractionHandler();\n    styleSheetObserver();\n    styleDeclarationObserver();\n    fontObserver();\n    pluginHandlers.forEach(function (h) {\n      return h();\n    });\n  };\n}\n\nexport { INPUT_TAGS, initMutationObserver, initObservers, initScrollObserver, mutationBuffers };","map":null,"metadata":{},"sourceType":"module"}