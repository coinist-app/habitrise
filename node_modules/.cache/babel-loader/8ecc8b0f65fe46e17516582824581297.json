{"ast":null,"code":"import { __values, __spreadArray, __read, __assign } from '../../ext/tslib/tslib.es6.js';\nimport { createCache, rebuild, buildNodeWithSN, NodeType } from '../../../rrweb-snapshot/es/rrweb-snapshot.js';\nimport * as mitt_es from '../../../../ext/mitt/dist/mitt.es.js';\nimport mitt$1 from '../../../../ext/mitt/dist/mitt.es.js';\nimport { polyfill } from './smoothscroll.js';\nimport { Timer } from './timer.js';\nimport { createPlayerService, createSpeedService } from './machine.js';\nimport { ReplayerEvents, EventType, IncrementalSource, MouseInteractions } from '../types.js';\nimport { polyfill as polyfill$1, isIframeINode, hasShadowRoot, queueToResolveTrees, iterateResolveTree, getBaseDimension, createMirror, TreeIndex } from '../utils.js';\nimport rules from './styles/inject-style.js';\nimport { getNestedRule, StyleRuleType, getPositionsAndIndex, storeCSSRules, applyVirtualStyleRulesToNode } from './virtual-styles.js';\nimport canvasMutation from './canvas/index.js';\nvar SKIP_TIME_THRESHOLD = 10 * 1000;\nvar SKIP_TIME_INTERVAL = 5 * 1000;\nvar mitt = mitt$1 || mitt_es;\nvar REPLAY_CONSOLE_PREFIX = '[replayer]';\nvar defaultMouseTailConfig = {\n  duration: 500,\n  lineCap: 'round',\n  lineWidth: 3,\n  strokeStyle: 'red'\n};\n\nfunction indicatesTouchDevice(e) {\n  return e.type == EventType.IncrementalSnapshot && (e.data.source == IncrementalSource.TouchMove || e.data.source == IncrementalSource.MouseInteraction && e.data.type == MouseInteractions.TouchStart);\n}\n\nvar Replayer = function () {\n  function Replayer(events, config) {\n    var _this = this;\n\n    this.mouseTail = null;\n    this.tailPositions = [];\n    this.emitter = mitt();\n    this.legacy_missingNodeRetryMap = {};\n    this.cache = createCache();\n    this.imageMap = new Map();\n    this.mirror = createMirror();\n    this.firstFullSnapshot = null;\n    this.newDocumentQueue = [];\n    this.mousePos = null;\n    this.touchActive = null;\n\n    if (!(config === null || config === void 0 ? void 0 : config.liveMode) && events.length < 2) {\n      throw new Error('Replayer need at least 2 events.');\n    }\n\n    var defaultConfig = {\n      speed: 1,\n      maxSpeed: 360,\n      root: document.body,\n      loadTimeout: 0,\n      skipInactive: false,\n      showWarning: true,\n      showDebug: false,\n      blockClass: 'rr-block',\n      liveMode: false,\n      insertStyleRules: [],\n      triggerFocus: true,\n      UNSAFE_replayCanvas: false,\n      pauseAnimation: true,\n      mouseTail: defaultMouseTailConfig\n    };\n    this.config = Object.assign({}, defaultConfig, config);\n    this.handleResize = this.handleResize.bind(this);\n    this.getCastFn = this.getCastFn.bind(this);\n    this.applyEventsSynchronously = this.applyEventsSynchronously.bind(this);\n    this.emitter.on(ReplayerEvents.Resize, this.handleResize);\n    this.setupDom();\n    this.treeIndex = new TreeIndex();\n    this.fragmentParentMap = new Map();\n    this.elementStateMap = new Map();\n    this.virtualStyleRulesMap = new Map();\n    this.emitter.on(ReplayerEvents.Flush, function () {\n      var e_1, _a, e_2, _b, e_3, _c, e_4, _d;\n\n      var _e = _this.treeIndex.flush(),\n          scrollMap = _e.scrollMap,\n          inputMap = _e.inputMap,\n          mutationData = _e.mutationData;\n\n      _this.fragmentParentMap.forEach(function (parent, frag) {\n        return _this.restoreRealParent(frag, parent);\n      });\n\n      try {\n        for (var _f = __values(mutationData.texts), _g = _f.next(); !_g.done; _g = _f.next()) {\n          var d = _g.value;\n\n          _this.applyText(d, mutationData);\n        }\n      } catch (e_1_1) {\n        e_1 = {\n          error: e_1_1\n        };\n      } finally {\n        try {\n          if (_g && !_g.done && (_a = _f.return)) _a.call(_f);\n        } finally {\n          if (e_1) throw e_1.error;\n        }\n      }\n\n      try {\n        for (var _h = __values(_this.virtualStyleRulesMap.keys()), _j = _h.next(); !_j.done; _j = _h.next()) {\n          var node = _j.value;\n\n          _this.restoreNodeSheet(node);\n        }\n      } catch (e_2_1) {\n        e_2 = {\n          error: e_2_1\n        };\n      } finally {\n        try {\n          if (_j && !_j.done && (_b = _h.return)) _b.call(_h);\n        } finally {\n          if (e_2) throw e_2.error;\n        }\n      }\n\n      _this.fragmentParentMap.clear();\n\n      _this.elementStateMap.clear();\n\n      _this.virtualStyleRulesMap.clear();\n\n      try {\n        for (var _k = __values(scrollMap.values()), _l = _k.next(); !_l.done; _l = _k.next()) {\n          var d = _l.value;\n\n          _this.applyScroll(d, true);\n        }\n      } catch (e_3_1) {\n        e_3 = {\n          error: e_3_1\n        };\n      } finally {\n        try {\n          if (_l && !_l.done && (_c = _k.return)) _c.call(_k);\n        } finally {\n          if (e_3) throw e_3.error;\n        }\n      }\n\n      try {\n        for (var _m = __values(inputMap.values()), _o = _m.next(); !_o.done; _o = _m.next()) {\n          var d = _o.value;\n\n          _this.applyInput(d);\n        }\n      } catch (e_4_1) {\n        e_4 = {\n          error: e_4_1\n        };\n      } finally {\n        try {\n          if (_o && !_o.done && (_d = _m.return)) _d.call(_m);\n        } finally {\n          if (e_4) throw e_4.error;\n        }\n      }\n    });\n    this.emitter.on(ReplayerEvents.PlayBack, function () {\n      _this.firstFullSnapshot = null;\n\n      _this.mirror.reset();\n    });\n    var timer = new Timer([], (config === null || config === void 0 ? void 0 : config.speed) || defaultConfig.speed);\n    this.service = createPlayerService({\n      events: events.map(function (e) {\n        if (config && config.unpackFn) {\n          return config.unpackFn(e);\n        }\n\n        return e;\n      }).sort(function (a1, a2) {\n        return a1.timestamp - a2.timestamp;\n      }),\n      timer: timer,\n      timeOffset: 0,\n      baselineTime: 0,\n      lastPlayedEvent: null\n    }, {\n      getCastFn: this.getCastFn,\n      applyEventsSynchronously: this.applyEventsSynchronously,\n      emitter: this.emitter\n    });\n    this.service.start();\n    this.service.subscribe(function (state) {\n      _this.emitter.emit(ReplayerEvents.StateChange, {\n        player: state\n      });\n    });\n    this.speedService = createSpeedService({\n      normalSpeed: -1,\n      timer: timer\n    });\n    this.speedService.start();\n    this.speedService.subscribe(function (state) {\n      _this.emitter.emit(ReplayerEvents.StateChange, {\n        speed: state\n      });\n    });\n    var firstMeta = this.service.state.context.events.find(function (e) {\n      return e.type === EventType.Meta;\n    });\n    var firstFullsnapshot = this.service.state.context.events.find(function (e) {\n      return e.type === EventType.FullSnapshot;\n    });\n\n    if (firstMeta) {\n      var _a = firstMeta.data,\n          width_1 = _a.width,\n          height_1 = _a.height;\n      setTimeout(function () {\n        _this.emitter.emit(ReplayerEvents.Resize, {\n          width: width_1,\n          height: height_1\n        });\n      }, 0);\n    }\n\n    if (firstFullsnapshot) {\n      setTimeout(function () {\n        if (_this.firstFullSnapshot) {\n          return;\n        }\n\n        _this.firstFullSnapshot = firstFullsnapshot;\n\n        _this.rebuildFullSnapshot(firstFullsnapshot);\n\n        _this.iframe.contentWindow.scrollTo(firstFullsnapshot.data.initialOffset);\n      }, 1);\n    }\n\n    if (this.service.state.context.events.find(indicatesTouchDevice)) {\n      this.mouse.classList.add('touch-device');\n    }\n  }\n\n  Object.defineProperty(Replayer.prototype, \"timer\", {\n    get: function get() {\n      return this.service.state.context.timer;\n    },\n    enumerable: false,\n    configurable: true\n  });\n\n  Replayer.prototype.on = function (event, handler) {\n    this.emitter.on(event, handler);\n    return this;\n  };\n\n  Replayer.prototype.off = function (event, handler) {\n    this.emitter.off(event, handler);\n    return this;\n  };\n\n  Replayer.prototype.setConfig = function (config) {\n    var _this = this;\n\n    Object.keys(config).forEach(function (key) {\n      _this.config[key] = config[key];\n    });\n\n    if (!this.config.skipInactive) {\n      this.backToNormal();\n    }\n\n    if (typeof config.speed !== 'undefined') {\n      this.speedService.send({\n        type: 'SET_SPEED',\n        payload: {\n          speed: config.speed\n        }\n      });\n    }\n\n    if (typeof config.mouseTail !== 'undefined') {\n      if (config.mouseTail === false) {\n        if (this.mouseTail) {\n          this.mouseTail.style.display = 'none';\n        }\n      } else {\n        if (!this.mouseTail) {\n          this.mouseTail = document.createElement('canvas');\n          this.mouseTail.width = Number.parseFloat(this.iframe.width);\n          this.mouseTail.height = Number.parseFloat(this.iframe.height);\n          this.mouseTail.classList.add('replayer-mouse-tail');\n          this.wrapper.insertBefore(this.mouseTail, this.iframe);\n        }\n\n        this.mouseTail.style.display = 'inherit';\n      }\n    }\n  };\n\n  Replayer.prototype.getMetaData = function () {\n    var firstEvent = this.service.state.context.events[0];\n    var lastEvent = this.service.state.context.events[this.service.state.context.events.length - 1];\n    return {\n      startTime: firstEvent.timestamp,\n      endTime: lastEvent.timestamp,\n      totalTime: lastEvent.timestamp - firstEvent.timestamp\n    };\n  };\n\n  Replayer.prototype.getCurrentTime = function () {\n    return this.timer.timeOffset + this.getTimeOffset();\n  };\n\n  Replayer.prototype.getTimeOffset = function () {\n    var _a = this.service.state.context,\n        baselineTime = _a.baselineTime,\n        events = _a.events;\n    return baselineTime - events[0].timestamp;\n  };\n\n  Replayer.prototype.getMirror = function () {\n    return this.mirror;\n  };\n\n  Replayer.prototype.play = function (timeOffset) {\n    var _a;\n\n    if (timeOffset === void 0) {\n      timeOffset = 0;\n    }\n\n    if (this.service.state.matches('paused')) {\n      this.service.send({\n        type: 'PLAY',\n        payload: {\n          timeOffset: timeOffset\n        }\n      });\n    } else {\n      this.service.send({\n        type: 'PAUSE'\n      });\n      this.service.send({\n        type: 'PLAY',\n        payload: {\n          timeOffset: timeOffset\n        }\n      });\n    }\n\n    (_a = this.iframe.contentDocument) === null || _a === void 0 ? void 0 : _a.getElementsByTagName('html')[0].classList.remove('rrweb-paused');\n    this.emitter.emit(ReplayerEvents.Start);\n  };\n\n  Replayer.prototype.pause = function (timeOffset) {\n    var _a;\n\n    if (timeOffset === undefined && this.service.state.matches('playing')) {\n      this.service.send({\n        type: 'PAUSE'\n      });\n    }\n\n    if (typeof timeOffset === 'number') {\n      this.play(timeOffset);\n      this.service.send({\n        type: 'PAUSE'\n      });\n    }\n\n    (_a = this.iframe.contentDocument) === null || _a === void 0 ? void 0 : _a.getElementsByTagName('html')[0].classList.add('rrweb-paused');\n    this.emitter.emit(ReplayerEvents.Pause);\n  };\n\n  Replayer.prototype.resume = function (timeOffset) {\n    if (timeOffset === void 0) {\n      timeOffset = 0;\n    }\n\n    console.warn(\"The 'resume' will be departed in 1.0. Please use 'play' method which has the same interface.\");\n    this.play(timeOffset);\n    this.emitter.emit(ReplayerEvents.Resume);\n  };\n\n  Replayer.prototype.startLive = function (baselineTime) {\n    this.service.send({\n      type: 'TO_LIVE',\n      payload: {\n        baselineTime: baselineTime\n      }\n    });\n  };\n\n  Replayer.prototype.addEvent = function (rawEvent) {\n    var _this = this;\n\n    var event = this.config.unpackFn ? this.config.unpackFn(rawEvent) : rawEvent;\n\n    if (indicatesTouchDevice(event)) {\n      this.mouse.classList.add('touch-device');\n    }\n\n    Promise.resolve().then(function () {\n      return _this.service.send({\n        type: 'ADD_EVENT',\n        payload: {\n          event: event\n        }\n      });\n    });\n  };\n\n  Replayer.prototype.enableInteract = function () {\n    this.iframe.setAttribute('scrolling', 'auto');\n    this.iframe.style.pointerEvents = 'auto';\n  };\n\n  Replayer.prototype.disableInteract = function () {\n    this.iframe.setAttribute('scrolling', 'no');\n    this.iframe.style.pointerEvents = 'none';\n  };\n\n  Replayer.prototype.resetCache = function () {\n    this.cache = createCache();\n  };\n\n  Replayer.prototype.setupDom = function () {\n    this.wrapper = document.createElement('div');\n    this.wrapper.classList.add('replayer-wrapper');\n    this.config.root.appendChild(this.wrapper);\n    this.mouse = document.createElement('div');\n    this.mouse.classList.add('replayer-mouse');\n    this.wrapper.appendChild(this.mouse);\n\n    if (this.config.mouseTail !== false) {\n      this.mouseTail = document.createElement('canvas');\n      this.mouseTail.classList.add('replayer-mouse-tail');\n      this.mouseTail.style.display = 'inherit';\n      this.wrapper.appendChild(this.mouseTail);\n    }\n\n    this.iframe = document.createElement('iframe');\n    var attributes = ['allow-same-origin'];\n\n    if (this.config.UNSAFE_replayCanvas) {\n      attributes.push('allow-scripts');\n    }\n\n    this.iframe.style.display = 'none';\n    this.iframe.setAttribute('sandbox', attributes.join(' '));\n    this.disableInteract();\n    this.wrapper.appendChild(this.iframe);\n\n    if (this.iframe.contentWindow && this.iframe.contentDocument) {\n      polyfill(this.iframe.contentWindow, this.iframe.contentDocument);\n      polyfill$1(this.iframe.contentWindow);\n    }\n  };\n\n  Replayer.prototype.handleResize = function (dimension) {\n    var e_5, _a;\n\n    this.iframe.style.display = 'inherit';\n\n    try {\n      for (var _b = __values([this.mouseTail, this.iframe]), _c = _b.next(); !_c.done; _c = _b.next()) {\n        var el = _c.value;\n\n        if (!el) {\n          continue;\n        }\n\n        el.setAttribute('width', String(dimension.width));\n        el.setAttribute('height', String(dimension.height));\n      }\n    } catch (e_5_1) {\n      e_5 = {\n        error: e_5_1\n      };\n    } finally {\n      try {\n        if (_c && !_c.done && (_a = _b.return)) _a.call(_b);\n      } finally {\n        if (e_5) throw e_5.error;\n      }\n    }\n  };\n\n  Replayer.prototype.applyEventsSynchronously = function (events) {\n    var e_6, _a;\n\n    try {\n      for (var events_1 = __values(events), events_1_1 = events_1.next(); !events_1_1.done; events_1_1 = events_1.next()) {\n        var event_1 = events_1_1.value;\n\n        switch (event_1.type) {\n          case EventType.DomContentLoaded:\n          case EventType.Load:\n          case EventType.Custom:\n            continue;\n\n          case EventType.FullSnapshot:\n          case EventType.Meta:\n          case EventType.Plugin:\n            break;\n\n          case EventType.IncrementalSnapshot:\n            switch (event_1.data.source) {\n              case IncrementalSource.MediaInteraction:\n                continue;\n\n              default:\n                break;\n            }\n\n            break;\n\n          default:\n            break;\n        }\n\n        var castFn = this.getCastFn(event_1, true);\n        castFn();\n      }\n    } catch (e_6_1) {\n      e_6 = {\n        error: e_6_1\n      };\n    } finally {\n      try {\n        if (events_1_1 && !events_1_1.done && (_a = events_1.return)) _a.call(events_1);\n      } finally {\n        if (e_6) throw e_6.error;\n      }\n    }\n\n    if (this.mousePos) {\n      this.moveAndHover(this.mousePos.x, this.mousePos.y, this.mousePos.id, true, this.mousePos.debugData);\n    }\n\n    this.mousePos = null;\n\n    if (this.touchActive === true) {\n      this.mouse.classList.add('touch-active');\n    } else if (this.touchActive === false) {\n      this.mouse.classList.remove('touch-active');\n    }\n\n    this.touchActive = null;\n  };\n\n  Replayer.prototype.getCastFn = function (event, isSync) {\n    var _this = this;\n\n    if (isSync === void 0) {\n      isSync = false;\n    }\n\n    var castFn;\n\n    switch (event.type) {\n      case EventType.DomContentLoaded:\n      case EventType.Load:\n        break;\n\n      case EventType.Custom:\n        castFn = function castFn() {\n          _this.emitter.emit(ReplayerEvents.CustomEvent, event);\n        };\n\n        break;\n\n      case EventType.Meta:\n        castFn = function castFn() {\n          return _this.emitter.emit(ReplayerEvents.Resize, {\n            width: event.data.width,\n            height: event.data.height\n          });\n        };\n\n        break;\n\n      case EventType.FullSnapshot:\n        castFn = function castFn() {\n          if (_this.firstFullSnapshot) {\n            if (_this.firstFullSnapshot === event) {\n              _this.firstFullSnapshot = true;\n              return;\n            }\n          } else {\n            _this.firstFullSnapshot = true;\n          }\n\n          _this.rebuildFullSnapshot(event, isSync);\n\n          _this.iframe.contentWindow.scrollTo(event.data.initialOffset);\n        };\n\n        break;\n\n      case EventType.IncrementalSnapshot:\n        castFn = function castFn() {\n          var e_7, _a;\n\n          _this.applyIncremental(event, isSync);\n\n          if (isSync) {\n            return;\n          }\n\n          if (event === _this.nextUserInteractionEvent) {\n            _this.nextUserInteractionEvent = null;\n\n            _this.backToNormal();\n          }\n\n          if (_this.config.skipInactive && !_this.nextUserInteractionEvent) {\n            try {\n              for (var _b = __values(_this.service.state.context.events), _c = _b.next(); !_c.done; _c = _b.next()) {\n                var _event = _c.value;\n\n                if (_event.timestamp <= event.timestamp) {\n                  continue;\n                }\n\n                if (_this.isUserInteraction(_event)) {\n                  if (_event.delay - event.delay > SKIP_TIME_THRESHOLD * _this.speedService.state.context.timer.speed) {\n                    _this.nextUserInteractionEvent = _event;\n                  }\n\n                  break;\n                }\n              }\n            } catch (e_7_1) {\n              e_7 = {\n                error: e_7_1\n              };\n            } finally {\n              try {\n                if (_c && !_c.done && (_a = _b.return)) _a.call(_b);\n              } finally {\n                if (e_7) throw e_7.error;\n              }\n            }\n\n            if (_this.nextUserInteractionEvent) {\n              var skipTime = _this.nextUserInteractionEvent.delay - event.delay;\n              var payload = {\n                speed: Math.min(Math.round(skipTime / SKIP_TIME_INTERVAL), _this.config.maxSpeed)\n              };\n\n              _this.speedService.send({\n                type: 'FAST_FORWARD',\n                payload: payload\n              });\n\n              _this.emitter.emit(ReplayerEvents.SkipStart, payload);\n            }\n          }\n        };\n\n        break;\n    }\n\n    var wrappedCastFn = function wrappedCastFn() {\n      var e_8, _a;\n\n      if (castFn) {\n        castFn();\n      }\n\n      try {\n        for (var _b = __values(_this.config.plugins || []), _c = _b.next(); !_c.done; _c = _b.next()) {\n          var plugin = _c.value;\n          plugin.handler(event, isSync, {\n            replayer: _this\n          });\n        }\n      } catch (e_8_1) {\n        e_8 = {\n          error: e_8_1\n        };\n      } finally {\n        try {\n          if (_c && !_c.done && (_a = _b.return)) _a.call(_b);\n        } finally {\n          if (e_8) throw e_8.error;\n        }\n      }\n\n      _this.service.send({\n        type: 'CAST_EVENT',\n        payload: {\n          event: event\n        }\n      });\n\n      var last_index = _this.service.state.context.events.length - 1;\n\n      if (event === _this.service.state.context.events[last_index]) {\n        var finish_1 = function finish_1() {\n          if (last_index < _this.service.state.context.events.length - 1) {\n            return;\n          }\n\n          _this.backToNormal();\n\n          _this.service.send('END');\n\n          _this.emitter.emit(ReplayerEvents.Finish);\n        };\n\n        if (event.type === EventType.IncrementalSnapshot && event.data.source === IncrementalSource.MouseMove && event.data.positions.length) {\n          setTimeout(function () {\n            finish_1();\n          }, Math.max(0, -event.data.positions[0].timeOffset + 50));\n        } else {\n          finish_1();\n        }\n      }\n\n      _this.emitter.emit(ReplayerEvents.EventCast, event);\n    };\n\n    return wrappedCastFn;\n  };\n\n  Replayer.prototype.rebuildFullSnapshot = function (event, isSync) {\n    var e_9, _a;\n\n    var _this = this;\n\n    if (isSync === void 0) {\n      isSync = false;\n    }\n\n    if (!this.iframe.contentDocument) {\n      return console.warn('Looks like your replayer has been destroyed.');\n    }\n\n    if (Object.keys(this.legacy_missingNodeRetryMap).length) {\n      console.warn('Found unresolved missing node map', this.legacy_missingNodeRetryMap);\n    }\n\n    this.legacy_missingNodeRetryMap = {};\n    var collected = [];\n    this.mirror.map = rebuild(event.data.node, {\n      doc: this.iframe.contentDocument,\n      afterAppend: function afterAppend(builtNode) {\n        _this.collectIframeAndAttachDocument(collected, builtNode);\n      },\n      cache: this.cache\n    })[1];\n\n    var _loop_1 = function _loop_1(mutationInQueue, builtNode) {\n      this_1.attachDocumentToIframe(mutationInQueue, builtNode);\n      this_1.newDocumentQueue = this_1.newDocumentQueue.filter(function (m) {\n        return m !== mutationInQueue;\n      });\n    };\n\n    var this_1 = this;\n\n    try {\n      for (var collected_1 = __values(collected), collected_1_1 = collected_1.next(); !collected_1_1.done; collected_1_1 = collected_1.next()) {\n        var _b = collected_1_1.value,\n            mutationInQueue = _b.mutationInQueue,\n            builtNode = _b.builtNode;\n\n        _loop_1(mutationInQueue, builtNode);\n      }\n    } catch (e_9_1) {\n      e_9 = {\n        error: e_9_1\n      };\n    } finally {\n      try {\n        if (collected_1_1 && !collected_1_1.done && (_a = collected_1.return)) _a.call(collected_1);\n      } finally {\n        if (e_9) throw e_9.error;\n      }\n    }\n\n    var _c = this.iframe.contentDocument,\n        documentElement = _c.documentElement,\n        head = _c.head;\n    this.insertStyleRules(documentElement, head);\n\n    if (!this.service.state.matches('playing')) {\n      this.iframe.contentDocument.getElementsByTagName('html')[0].classList.add('rrweb-paused');\n    }\n\n    this.emitter.emit(ReplayerEvents.FullsnapshotRebuilded, event);\n\n    if (!isSync) {\n      this.waitForStylesheetLoad();\n    }\n\n    if (this.config.UNSAFE_replayCanvas) {\n      this.preloadAllImages();\n    }\n  };\n\n  Replayer.prototype.insertStyleRules = function (documentElement, head) {\n    var styleEl = document.createElement('style');\n    documentElement.insertBefore(styleEl, head);\n    var injectStylesRules = rules(this.config.blockClass).concat(this.config.insertStyleRules);\n\n    if (this.config.pauseAnimation) {\n      injectStylesRules.push('html.rrweb-paused *, html.rrweb-paused *:before, html.rrweb-paused *:after { animation-play-state: paused !important; }');\n    }\n\n    for (var idx = 0; idx < injectStylesRules.length; idx++) {\n      styleEl.sheet.insertRule(injectStylesRules[idx], idx);\n    }\n  };\n\n  Replayer.prototype.attachDocumentToIframe = function (mutation, iframeEl) {\n    var e_10, _a;\n\n    var _this = this;\n\n    var collected = [];\n\n    if (!iframeEl.contentDocument) {\n      var parent_1 = iframeEl.parentNode;\n\n      while (parent_1) {\n        if (this.fragmentParentMap.has(parent_1)) {\n          var frag = parent_1;\n          var realParent = this.fragmentParentMap.get(frag);\n          this.restoreRealParent(frag, realParent);\n          break;\n        }\n\n        parent_1 = parent_1.parentNode;\n      }\n    }\n\n    buildNodeWithSN(mutation.node, {\n      doc: iframeEl.contentDocument,\n      map: this.mirror.map,\n      hackCss: true,\n      skipChild: false,\n      afterAppend: function afterAppend(builtNode) {\n        _this.collectIframeAndAttachDocument(collected, builtNode);\n\n        if (builtNode.__sn.type === NodeType.Element && builtNode.__sn.tagName.toUpperCase() === 'HTML') {\n          var _a = iframeEl.contentDocument,\n              documentElement = _a.documentElement,\n              head = _a.head;\n\n          _this.insertStyleRules(documentElement, head);\n        }\n      },\n      cache: this.cache\n    });\n\n    var _loop_2 = function _loop_2(mutationInQueue, builtNode) {\n      this_2.attachDocumentToIframe(mutationInQueue, builtNode);\n      this_2.newDocumentQueue = this_2.newDocumentQueue.filter(function (m) {\n        return m !== mutationInQueue;\n      });\n    };\n\n    var this_2 = this;\n\n    try {\n      for (var collected_2 = __values(collected), collected_2_1 = collected_2.next(); !collected_2_1.done; collected_2_1 = collected_2.next()) {\n        var _b = collected_2_1.value,\n            mutationInQueue = _b.mutationInQueue,\n            builtNode = _b.builtNode;\n\n        _loop_2(mutationInQueue, builtNode);\n      }\n    } catch (e_10_1) {\n      e_10 = {\n        error: e_10_1\n      };\n    } finally {\n      try {\n        if (collected_2_1 && !collected_2_1.done && (_a = collected_2.return)) _a.call(collected_2);\n      } finally {\n        if (e_10) throw e_10.error;\n      }\n    }\n  };\n\n  Replayer.prototype.collectIframeAndAttachDocument = function (collected, builtNode) {\n    if (isIframeINode(builtNode)) {\n      var mutationInQueue = this.newDocumentQueue.find(function (m) {\n        return m.parentId === builtNode.__sn.id;\n      });\n\n      if (mutationInQueue) {\n        collected.push({\n          mutationInQueue: mutationInQueue,\n          builtNode: builtNode\n        });\n      }\n    }\n  };\n\n  Replayer.prototype.waitForStylesheetLoad = function () {\n    var _this = this;\n\n    var _a;\n\n    var head = (_a = this.iframe.contentDocument) === null || _a === void 0 ? void 0 : _a.head;\n\n    if (head) {\n      var unloadSheets_1 = new Set();\n      var timer_1;\n      var beforeLoadState_1 = this.service.state;\n\n      var stateHandler_1 = function stateHandler_1() {\n        beforeLoadState_1 = _this.service.state;\n      };\n\n      this.emitter.on(ReplayerEvents.Start, stateHandler_1);\n      this.emitter.on(ReplayerEvents.Pause, stateHandler_1);\n\n      var unsubscribe_1 = function unsubscribe_1() {\n        _this.emitter.off(ReplayerEvents.Start, stateHandler_1);\n\n        _this.emitter.off(ReplayerEvents.Pause, stateHandler_1);\n      };\n\n      head.querySelectorAll('link[rel=\"stylesheet\"]').forEach(function (css) {\n        if (!css.sheet) {\n          unloadSheets_1.add(css);\n          css.addEventListener('load', function () {\n            unloadSheets_1.delete(css);\n\n            if (unloadSheets_1.size === 0 && timer_1 !== -1) {\n              if (beforeLoadState_1.matches('playing')) {\n                _this.play(_this.getCurrentTime());\n              }\n\n              _this.emitter.emit(ReplayerEvents.LoadStylesheetEnd);\n\n              if (timer_1) {\n                clearTimeout(timer_1);\n              }\n\n              unsubscribe_1();\n            }\n          });\n        }\n      });\n\n      if (unloadSheets_1.size > 0) {\n        this.service.send({\n          type: 'PAUSE'\n        });\n        this.emitter.emit(ReplayerEvents.LoadStylesheetStart);\n        timer_1 = setTimeout(function () {\n          if (beforeLoadState_1.matches('playing')) {\n            _this.play(_this.getCurrentTime());\n          }\n\n          timer_1 = -1;\n          unsubscribe_1();\n        }, this.config.loadTimeout);\n      }\n    }\n  };\n\n  Replayer.prototype.hasImageArg = function (args) {\n    var e_11, _a;\n\n    try {\n      for (var args_1 = __values(args), args_1_1 = args_1.next(); !args_1_1.done; args_1_1 = args_1.next()) {\n        var arg = args_1_1.value;\n\n        if (!arg || typeof arg !== 'object') {} else if ('rr_type' in arg && 'args' in arg) {\n          if (this.hasImageArg(arg.args)) return true;\n        } else if ('rr_type' in arg && arg.rr_type === 'HTMLImageElement') {\n          return true;\n        } else if (arg instanceof Array) {\n          if (this.hasImageArg(arg)) return true;\n        }\n      }\n    } catch (e_11_1) {\n      e_11 = {\n        error: e_11_1\n      };\n    } finally {\n      try {\n        if (args_1_1 && !args_1_1.done && (_a = args_1.return)) _a.call(args_1);\n      } finally {\n        if (e_11) throw e_11.error;\n      }\n    }\n\n    return false;\n  };\n\n  Replayer.prototype.getImageArgs = function (args) {\n    var e_12, _a;\n\n    var images = [];\n\n    try {\n      for (var args_2 = __values(args), args_2_1 = args_2.next(); !args_2_1.done; args_2_1 = args_2.next()) {\n        var arg = args_2_1.value;\n\n        if (!arg || typeof arg !== 'object') {} else if ('rr_type' in arg && 'args' in arg) {\n          images.push.apply(images, __spreadArray([], __read(this.getImageArgs(arg.args)), false));\n        } else if ('rr_type' in arg && arg.rr_type === 'HTMLImageElement') {\n          images.push(arg.src);\n        } else if (arg instanceof Array) {\n          images.push.apply(images, __spreadArray([], __read(this.getImageArgs(arg)), false));\n        }\n      }\n    } catch (e_12_1) {\n      e_12 = {\n        error: e_12_1\n      };\n    } finally {\n      try {\n        if (args_2_1 && !args_2_1.done && (_a = args_2.return)) _a.call(args_2);\n      } finally {\n        if (e_12) throw e_12.error;\n      }\n    }\n\n    return images;\n  };\n\n  Replayer.prototype.preloadAllImages = function () {\n    var e_13, _a;\n\n    var _this = this;\n\n    this.service.state;\n\n    var stateHandler = function stateHandler() {\n      _this.service.state;\n    };\n\n    this.emitter.on(ReplayerEvents.Start, stateHandler);\n    this.emitter.on(ReplayerEvents.Pause, stateHandler);\n\n    var _loop_3 = function _loop_3(event_2) {\n      if (event_2.type === EventType.IncrementalSnapshot && event_2.data.source === IncrementalSource.CanvasMutation) if ('commands' in event_2.data) {\n        event_2.data.commands.forEach(function (c) {\n          return _this.preloadImages(c, event_2);\n        });\n      } else {\n        this_3.preloadImages(event_2.data, event_2);\n      }\n    };\n\n    var this_3 = this;\n\n    try {\n      for (var _b = __values(this.service.state.context.events), _c = _b.next(); !_c.done; _c = _b.next()) {\n        var event_2 = _c.value;\n\n        _loop_3(event_2);\n      }\n    } catch (e_13_1) {\n      e_13 = {\n        error: e_13_1\n      };\n    } finally {\n      try {\n        if (_c && !_c.done && (_a = _b.return)) _a.call(_b);\n      } finally {\n        if (e_13) throw e_13.error;\n      }\n    }\n  };\n\n  Replayer.prototype.preloadImages = function (data, event) {\n    var _this = this;\n\n    if (data.property === 'drawImage' && typeof data.args[0] === 'string' && !this.imageMap.has(event)) {\n      var canvas = document.createElement('canvas');\n      var ctx = canvas.getContext('2d');\n      var imgd = ctx === null || ctx === void 0 ? void 0 : ctx.createImageData(canvas.width, canvas.height);\n      imgd === null || imgd === void 0 ? void 0 : imgd.data;\n      JSON.parse(data.args[0]);\n      ctx === null || ctx === void 0 ? void 0 : ctx.putImageData(imgd, 0, 0);\n    } else if (this.hasImageArg(data.args)) {\n      this.getImageArgs(data.args).forEach(function (url) {\n        var image = new Image();\n        image.src = url;\n\n        _this.imageMap.set(url, image);\n      });\n    }\n  };\n\n  Replayer.prototype.applyIncremental = function (e, isSync) {\n    var _this = this;\n\n    var _a, _b;\n\n    var d = e.data;\n\n    switch (d.source) {\n      case IncrementalSource.Mutation:\n        {\n          if (isSync) {\n            d.adds.forEach(function (m) {\n              return _this.treeIndex.add(m);\n            });\n            d.texts.forEach(function (m) {\n              var target = _this.mirror.getNode(m.id);\n\n              var parent = target === null || target === void 0 ? void 0 : target.parentNode;\n              if (parent && _this.virtualStyleRulesMap.has(parent)) _this.virtualStyleRulesMap.delete(parent);\n\n              _this.treeIndex.text(m);\n            });\n            d.attributes.forEach(function (m) {\n              return _this.treeIndex.attribute(m);\n            });\n            d.removes.forEach(function (m) {\n              return _this.treeIndex.remove(m, _this.mirror);\n            });\n          }\n\n          try {\n            this.applyMutation(d, isSync);\n          } catch (error) {\n            this.warn(\"Exception in mutation \".concat(error.message || error), d);\n          }\n\n          break;\n        }\n\n      case IncrementalSource.Drag:\n      case IncrementalSource.TouchMove:\n      case IncrementalSource.MouseMove:\n        if (isSync) {\n          var lastPosition = d.positions[d.positions.length - 1];\n          this.mousePos = {\n            x: lastPosition.x,\n            y: lastPosition.y,\n            id: lastPosition.id,\n            debugData: d\n          };\n        } else {\n          d.positions.forEach(function (p) {\n            var action = {\n              doAction: function doAction() {\n                _this.moveAndHover(p.x, p.y, p.id, isSync, d);\n              },\n              delay: p.timeOffset + e.timestamp - _this.service.state.context.baselineTime\n            };\n\n            _this.timer.addAction(action);\n          });\n          this.timer.addAction({\n            doAction: function doAction() {},\n            delay: e.delay - ((_a = d.positions[0]) === null || _a === void 0 ? void 0 : _a.timeOffset)\n          });\n        }\n\n        break;\n\n      case IncrementalSource.MouseInteraction:\n        {\n          if (d.id === -1) {\n            break;\n          }\n\n          var event_3 = new Event(MouseInteractions[d.type].toLowerCase());\n          var target = this.mirror.getNode(d.id);\n\n          if (!target) {\n            return this.debugNodeNotFound(d, d.id);\n          }\n\n          this.emitter.emit(ReplayerEvents.MouseInteraction, {\n            type: d.type,\n            target: target\n          });\n          var triggerFocus = this.config.triggerFocus;\n\n          switch (d.type) {\n            case MouseInteractions.Blur:\n              if ('blur' in target) {\n                target.blur();\n              }\n\n              break;\n\n            case MouseInteractions.Focus:\n              if (triggerFocus && target.focus) {\n                target.focus({\n                  preventScroll: true\n                });\n              }\n\n              break;\n\n            case MouseInteractions.Click:\n            case MouseInteractions.TouchStart:\n            case MouseInteractions.TouchEnd:\n              if (isSync) {\n                if (d.type === MouseInteractions.TouchStart) {\n                  this.touchActive = true;\n                } else if (d.type === MouseInteractions.TouchEnd) {\n                  this.touchActive = false;\n                }\n\n                this.mousePos = {\n                  x: d.x,\n                  y: d.y,\n                  id: d.id,\n                  debugData: d\n                };\n              } else {\n                if (d.type === MouseInteractions.TouchStart) {\n                  this.tailPositions.length = 0;\n                }\n\n                this.moveAndHover(d.x, d.y, d.id, isSync, d);\n\n                if (d.type === MouseInteractions.Click) {\n                  this.mouse.classList.remove('active');\n                  void this.mouse.offsetWidth;\n                  this.mouse.classList.add('active');\n                } else if (d.type === MouseInteractions.TouchStart) {\n                  void this.mouse.offsetWidth;\n                  this.mouse.classList.add('touch-active');\n                } else if (d.type === MouseInteractions.TouchEnd) {\n                  this.mouse.classList.remove('touch-active');\n                }\n              }\n\n              break;\n\n            case MouseInteractions.TouchCancel:\n              if (isSync) {\n                this.touchActive = false;\n              } else {\n                this.mouse.classList.remove('touch-active');\n              }\n\n              break;\n\n            default:\n              target.dispatchEvent(event_3);\n          }\n\n          break;\n        }\n\n      case IncrementalSource.Scroll:\n        {\n          if (d.id === -1) {\n            break;\n          }\n\n          if (isSync) {\n            this.treeIndex.scroll(d);\n            break;\n          }\n\n          this.applyScroll(d, false);\n          break;\n        }\n\n      case IncrementalSource.ViewportResize:\n        this.emitter.emit(ReplayerEvents.Resize, {\n          width: d.width,\n          height: d.height\n        });\n        break;\n\n      case IncrementalSource.Input:\n        {\n          if (d.id === -1) {\n            break;\n          }\n\n          if (isSync) {\n            this.treeIndex.input(d);\n            break;\n          }\n\n          this.applyInput(d);\n          break;\n        }\n\n      case IncrementalSource.MediaInteraction:\n        {\n          var target = this.mirror.getNode(d.id);\n\n          if (!target) {\n            return this.debugNodeNotFound(d, d.id);\n          }\n\n          var mediaEl = target;\n\n          try {\n            if (d.currentTime) {\n              mediaEl.currentTime = d.currentTime;\n            }\n\n            if (d.volume) {\n              mediaEl.volume = d.volume;\n            }\n\n            if (d.muted) {\n              mediaEl.muted = d.muted;\n            }\n\n            if (d.type === 1) {\n              mediaEl.pause();\n            }\n\n            if (d.type === 0) {\n              mediaEl.play();\n            }\n          } catch (error) {\n            if (this.config.showWarning) {\n              console.warn(\"Failed to replay media interactions: \".concat(error.message || error));\n            }\n          }\n\n          break;\n        }\n\n      case IncrementalSource.StyleSheetRule:\n        {\n          var target = this.mirror.getNode(d.id);\n\n          if (!target) {\n            return this.debugNodeNotFound(d, d.id);\n          }\n\n          var styleEl = target;\n          var parent_2 = target.parentNode;\n          var usingVirtualParent_1 = this.fragmentParentMap.has(parent_2);\n          var styleSheet_1 = usingVirtualParent_1 ? null : styleEl.sheet;\n          var rules_1;\n\n          if (!styleSheet_1) {\n            if (this.virtualStyleRulesMap.has(target)) {\n              rules_1 = this.virtualStyleRulesMap.get(target);\n            } else {\n              rules_1 = [];\n              this.virtualStyleRulesMap.set(target, rules_1);\n            }\n          }\n\n          if (d.adds) {\n            d.adds.forEach(function (_a) {\n              var rule = _a.rule,\n                  nestedIndex = _a.index;\n\n              if (styleSheet_1) {\n                try {\n                  if (Array.isArray(nestedIndex)) {\n                    var _b = getPositionsAndIndex(nestedIndex),\n                        positions = _b.positions,\n                        index = _b.index;\n\n                    var nestedRule = getNestedRule(styleSheet_1.cssRules, positions);\n                    nestedRule.insertRule(rule, index);\n                  } else {\n                    var index = nestedIndex === undefined ? undefined : Math.min(nestedIndex, styleSheet_1.cssRules.length);\n                    styleSheet_1.insertRule(rule, index);\n                  }\n                } catch (e) {}\n              } else {\n                rules_1 === null || rules_1 === void 0 ? void 0 : rules_1.push({\n                  cssText: rule,\n                  index: nestedIndex,\n                  type: StyleRuleType.Insert\n                });\n              }\n            });\n          }\n\n          if (d.removes) {\n            d.removes.forEach(function (_a) {\n              var nestedIndex = _a.index;\n\n              if (usingVirtualParent_1) {\n                rules_1 === null || rules_1 === void 0 ? void 0 : rules_1.push({\n                  index: nestedIndex,\n                  type: StyleRuleType.Remove\n                });\n              } else {\n                try {\n                  if (Array.isArray(nestedIndex)) {\n                    var _b = getPositionsAndIndex(nestedIndex),\n                        positions = _b.positions,\n                        index = _b.index;\n\n                    var nestedRule = getNestedRule(styleSheet_1.cssRules, positions);\n                    nestedRule.deleteRule(index || 0);\n                  } else {\n                    styleSheet_1 === null || styleSheet_1 === void 0 ? void 0 : styleSheet_1.deleteRule(nestedIndex);\n                  }\n                } catch (e) {}\n              }\n            });\n          }\n\n          break;\n        }\n\n      case IncrementalSource.StyleDeclaration:\n        {\n          var target = this.mirror.getNode(d.id);\n\n          if (!target) {\n            return this.debugNodeNotFound(d, d.id);\n          }\n\n          var styleEl = target;\n          var parent_3 = target.parentNode;\n          var usingVirtualParent = this.fragmentParentMap.has(parent_3);\n          var styleSheet = usingVirtualParent ? null : styleEl.sheet;\n          var rules = [];\n\n          if (!styleSheet) {\n            if (this.virtualStyleRulesMap.has(target)) {\n              rules = this.virtualStyleRulesMap.get(target);\n            } else {\n              rules = [];\n              this.virtualStyleRulesMap.set(target, rules);\n            }\n          }\n\n          if (d.set) {\n            if (styleSheet) {\n              var rule = getNestedRule(styleSheet.rules, d.index);\n              rule.style.setProperty(d.set.property, d.set.value, d.set.priority);\n            } else {\n              rules.push(__assign({\n                type: StyleRuleType.SetProperty,\n                index: d.index\n              }, d.set));\n            }\n          }\n\n          if (d.remove) {\n            if (styleSheet) {\n              var rule = getNestedRule(styleSheet.rules, d.index);\n              rule.style.removeProperty(d.remove.property);\n            } else {\n              rules.push(__assign({\n                type: StyleRuleType.RemoveProperty,\n                index: d.index\n              }, d.remove));\n            }\n          }\n\n          break;\n        }\n\n      case IncrementalSource.CanvasMutation:\n        {\n          if (!this.config.UNSAFE_replayCanvas) {\n            return;\n          }\n\n          var target = this.mirror.getNode(d.id);\n\n          if (!target) {\n            return this.debugNodeNotFound(d, d.id);\n          }\n\n          canvasMutation({\n            event: e,\n            mutation: d,\n            target: target,\n            imageMap: this.imageMap,\n            errorHandler: this.warnCanvasMutationFailed.bind(this)\n          });\n          break;\n        }\n\n      case IncrementalSource.Font:\n        {\n          try {\n            var fontFace = new FontFace(d.family, d.buffer ? new Uint8Array(JSON.parse(d.fontSource)) : d.fontSource, d.descriptors);\n            (_b = this.iframe.contentDocument) === null || _b === void 0 ? void 0 : _b.fonts.add(fontFace);\n          } catch (error) {\n            if (this.config.showWarning) {\n              console.warn(error);\n            }\n          }\n\n          break;\n        }\n    }\n  };\n\n  Replayer.prototype.applyMutation = function (d, useVirtualParent) {\n    var e_14, _a;\n\n    var _this = this;\n\n    d.removes.forEach(function (mutation) {\n      var target = _this.mirror.getNode(mutation.id);\n\n      if (!target) {\n        if (d.removes.find(function (r) {\n          return r.id === mutation.parentId;\n        })) {\n          return;\n        }\n\n        return _this.warnNodeNotFound(d, mutation.id);\n      }\n\n      if (_this.virtualStyleRulesMap.has(target)) {\n        _this.virtualStyleRulesMap.delete(target);\n      }\n\n      var parent = _this.mirror.getNode(mutation.parentId);\n\n      if (!parent) {\n        return _this.warnNodeNotFound(d, mutation.parentId);\n      }\n\n      if (mutation.isShadow && hasShadowRoot(parent)) {\n        parent = parent.shadowRoot;\n      }\n\n      _this.mirror.removeNodeFromMap(target);\n\n      if (parent) {\n        var realTarget = null;\n        var realParent = '__sn' in parent ? _this.fragmentParentMap.get(parent) : undefined;\n\n        if (realParent && realParent.contains(target)) {\n          parent = realParent;\n        } else if (_this.fragmentParentMap.has(target)) {\n          realTarget = _this.fragmentParentMap.get(target);\n\n          _this.fragmentParentMap.delete(target);\n\n          target = realTarget;\n        }\n\n        try {\n          parent.removeChild(target);\n        } catch (error) {\n          if (error instanceof DOMException) {\n            _this.warn('parent could not remove child in mutation', parent, realParent, target, realTarget, d);\n          } else {\n            throw error;\n          }\n        }\n      }\n    });\n\n    var legacy_missingNodeMap = __assign({}, this.legacy_missingNodeRetryMap);\n\n    var queue = [];\n\n    var nextNotInDOM = function nextNotInDOM(mutation) {\n      var next = null;\n\n      if (mutation.nextId) {\n        next = _this.mirror.getNode(mutation.nextId);\n      }\n\n      if (mutation.nextId !== null && mutation.nextId !== undefined && mutation.nextId !== -1 && !next) {\n        return true;\n      }\n\n      return false;\n    };\n\n    var appendNode = function appendNode(mutation) {\n      var e_15, _a;\n\n      var _b, _c;\n\n      if (!_this.iframe.contentDocument) {\n        return console.warn('Looks like your replayer has been destroyed.');\n      }\n\n      var parent = _this.mirror.getNode(mutation.parentId);\n\n      if (!parent) {\n        if (mutation.node.type === NodeType.Document) {\n          return _this.newDocumentQueue.push(mutation);\n        }\n\n        return queue.push(mutation);\n      }\n\n      var parentInDocument = null;\n\n      if (_this.iframe.contentDocument.contains) {\n        parentInDocument = _this.iframe.contentDocument.contains(parent);\n      } else if (_this.iframe.contentDocument.body.contains) {\n        parentInDocument = _this.iframe.contentDocument.body.contains(parent);\n      }\n\n      var hasIframeChild = ((_c = (_b = parent).getElementsByTagName) === null || _c === void 0 ? void 0 : _c.call(_b, 'iframe').length) > 0;\n\n      if (useVirtualParent && parentInDocument && !isIframeINode(parent) && !hasIframeChild) {\n        var virtualParent = document.createDocumentFragment();\n        _this.mirror.map[mutation.parentId] = virtualParent;\n\n        _this.fragmentParentMap.set(virtualParent, parent);\n\n        _this.storeState(parent);\n\n        while (parent.firstChild) {\n          virtualParent.appendChild(parent.firstChild);\n        }\n\n        parent = virtualParent;\n      }\n\n      if (mutation.node.isShadow) {\n        if (!hasShadowRoot(parent)) {\n          parent.attachShadow({\n            mode: 'open'\n          });\n          parent = parent.shadowRoot;\n        } else parent = parent.shadowRoot;\n      }\n\n      var previous = null;\n      var next = null;\n\n      if (mutation.previousId) {\n        previous = _this.mirror.getNode(mutation.previousId);\n      }\n\n      if (mutation.nextId) {\n        next = _this.mirror.getNode(mutation.nextId);\n      }\n\n      if (nextNotInDOM(mutation)) {\n        return queue.push(mutation);\n      }\n\n      if (mutation.node.rootId && !_this.mirror.getNode(mutation.node.rootId)) {\n        return;\n      }\n\n      var targetDoc = mutation.node.rootId ? _this.mirror.getNode(mutation.node.rootId) : _this.iframe.contentDocument;\n\n      if (isIframeINode(parent)) {\n        _this.attachDocumentToIframe(mutation, parent);\n\n        return;\n      }\n\n      var target = buildNodeWithSN(mutation.node, {\n        doc: targetDoc,\n        map: _this.mirror.map,\n        skipChild: true,\n        hackCss: true,\n        cache: _this.cache\n      });\n\n      if (mutation.previousId === -1 || mutation.nextId === -1) {\n        legacy_missingNodeMap[mutation.node.id] = {\n          node: target,\n          mutation: mutation\n        };\n        return;\n      }\n\n      if ('__sn' in parent && parent.__sn.type === NodeType.Element && parent.__sn.tagName === 'textarea' && mutation.node.type === NodeType.Text) {\n        try {\n          for (var _d = __values(Array.from(parent.childNodes)), _e = _d.next(); !_e.done; _e = _d.next()) {\n            var c = _e.value;\n\n            if (c.nodeType === parent.TEXT_NODE) {\n              parent.removeChild(c);\n            }\n          }\n        } catch (e_15_1) {\n          e_15 = {\n            error: e_15_1\n          };\n        } finally {\n          try {\n            if (_e && !_e.done && (_a = _d.return)) _a.call(_d);\n          } finally {\n            if (e_15) throw e_15.error;\n          }\n        }\n      }\n\n      if (previous && previous.nextSibling && previous.nextSibling.parentNode) {\n        parent.insertBefore(target, previous.nextSibling);\n      } else if (next && next.parentNode) {\n        parent.contains(next) ? parent.insertBefore(target, next) : parent.insertBefore(target, null);\n      } else {\n        if (parent === targetDoc) {\n          while (targetDoc.firstChild) {\n            targetDoc.removeChild(targetDoc.firstChild);\n          }\n        }\n\n        parent.appendChild(target);\n      }\n\n      if (isIframeINode(target)) {\n        var mutationInQueue_1 = _this.newDocumentQueue.find(function (m) {\n          return m.parentId === target.__sn.id;\n        });\n\n        if (mutationInQueue_1) {\n          _this.attachDocumentToIframe(mutationInQueue_1, target);\n\n          _this.newDocumentQueue = _this.newDocumentQueue.filter(function (m) {\n            return m !== mutationInQueue_1;\n          });\n        }\n      }\n\n      if (mutation.previousId || mutation.nextId) {\n        _this.legacy_resolveMissingNode(legacy_missingNodeMap, parent, target, mutation);\n      }\n    };\n\n    d.adds.forEach(function (mutation) {\n      appendNode(mutation);\n    });\n    var startTime = Date.now();\n\n    while (queue.length) {\n      var resolveTrees = queueToResolveTrees(queue);\n      queue.length = 0;\n\n      if (Date.now() - startTime > 500) {\n        this.warn('Timeout in the loop, please check the resolve tree data:', resolveTrees);\n        break;\n      }\n\n      try {\n        for (var resolveTrees_1 = (e_14 = void 0, __values(resolveTrees)), resolveTrees_1_1 = resolveTrees_1.next(); !resolveTrees_1_1.done; resolveTrees_1_1 = resolveTrees_1.next()) {\n          var tree = resolveTrees_1_1.value;\n          var parent_4 = this.mirror.getNode(tree.value.parentId);\n\n          if (!parent_4) {\n            this.debug('Drop resolve tree since there is no parent for the root node.', tree);\n          } else {\n            iterateResolveTree(tree, function (mutation) {\n              appendNode(mutation);\n            });\n          }\n        }\n      } catch (e_14_1) {\n        e_14 = {\n          error: e_14_1\n        };\n      } finally {\n        try {\n          if (resolveTrees_1_1 && !resolveTrees_1_1.done && (_a = resolveTrees_1.return)) _a.call(resolveTrees_1);\n        } finally {\n          if (e_14) throw e_14.error;\n        }\n      }\n    }\n\n    if (Object.keys(legacy_missingNodeMap).length) {\n      Object.assign(this.legacy_missingNodeRetryMap, legacy_missingNodeMap);\n    }\n\n    d.texts.forEach(function (mutation) {\n      var target = _this.mirror.getNode(mutation.id);\n\n      if (!target) {\n        if (d.removes.find(function (r) {\n          return r.id === mutation.id;\n        })) {\n          return;\n        }\n\n        return _this.warnNodeNotFound(d, mutation.id);\n      }\n\n      if (_this.fragmentParentMap.has(target)) {\n        target = _this.fragmentParentMap.get(target);\n      }\n\n      target.textContent = mutation.value;\n    });\n    d.attributes.forEach(function (mutation) {\n      var target = _this.mirror.getNode(mutation.id);\n\n      if (!target) {\n        if (d.removes.find(function (r) {\n          return r.id === mutation.id;\n        })) {\n          return;\n        }\n\n        return _this.warnNodeNotFound(d, mutation.id);\n      }\n\n      if (_this.fragmentParentMap.has(target)) {\n        target = _this.fragmentParentMap.get(target);\n      }\n\n      for (var attributeName in mutation.attributes) {\n        if (typeof attributeName === 'string') {\n          var value = mutation.attributes[attributeName];\n\n          if (value === null) {\n            target.removeAttribute(attributeName);\n          } else if (typeof value === 'string') {\n            try {\n              target.setAttribute(attributeName, value);\n            } catch (error) {\n              if (_this.config.showWarning) {\n                console.warn('An error occurred may due to the checkout feature.', error);\n              }\n            }\n          } else if (attributeName === 'style') {\n            var styleValues = value;\n            var targetEl = target;\n\n            for (var s in styleValues) {\n              if (styleValues[s] === false) {\n                targetEl.style.removeProperty(s);\n              } else if (styleValues[s] instanceof Array) {\n                var svp = styleValues[s];\n                targetEl.style.setProperty(s, svp[0], svp[1]);\n              } else {\n                var svs = styleValues[s];\n                targetEl.style.setProperty(s, svs);\n              }\n            }\n          }\n        }\n      }\n    });\n  };\n\n  Replayer.prototype.applyScroll = function (d, isSync) {\n    var target = this.mirror.getNode(d.id);\n\n    if (!target) {\n      return this.debugNodeNotFound(d, d.id);\n    }\n\n    if (target === this.iframe.contentDocument) {\n      this.iframe.contentWindow.scrollTo({\n        top: d.y,\n        left: d.x,\n        behavior: isSync ? 'auto' : 'smooth'\n      });\n    } else if (target.__sn.type === NodeType.Document) {\n      target.defaultView.scrollTo({\n        top: d.y,\n        left: d.x,\n        behavior: isSync ? 'auto' : 'smooth'\n      });\n    } else {\n      try {\n        target.scrollTop = d.y;\n        target.scrollLeft = d.x;\n      } catch (error) {}\n    }\n  };\n\n  Replayer.prototype.applyInput = function (d) {\n    var target = this.mirror.getNode(d.id);\n\n    if (!target) {\n      return this.debugNodeNotFound(d, d.id);\n    }\n\n    try {\n      target.checked = d.isChecked;\n      target.value = d.text;\n    } catch (error) {}\n  };\n\n  Replayer.prototype.applyText = function (d, mutation) {\n    var target = this.mirror.getNode(d.id);\n\n    if (!target) {\n      return this.debugNodeNotFound(mutation, d.id);\n    }\n\n    try {\n      target.textContent = d.value;\n    } catch (error) {}\n  };\n\n  Replayer.prototype.legacy_resolveMissingNode = function (map, parent, target, targetMutation) {\n    var previousId = targetMutation.previousId,\n        nextId = targetMutation.nextId;\n    var previousInMap = previousId && map[previousId];\n    var nextInMap = nextId && map[nextId];\n\n    if (previousInMap) {\n      var _a = previousInMap,\n          node = _a.node,\n          mutation = _a.mutation;\n      parent.insertBefore(node, target);\n      delete map[mutation.node.id];\n      delete this.legacy_missingNodeRetryMap[mutation.node.id];\n\n      if (mutation.previousId || mutation.nextId) {\n        this.legacy_resolveMissingNode(map, parent, node, mutation);\n      }\n    }\n\n    if (nextInMap) {\n      var _b = nextInMap,\n          node = _b.node,\n          mutation = _b.mutation;\n      parent.insertBefore(node, target.nextSibling);\n      delete map[mutation.node.id];\n      delete this.legacy_missingNodeRetryMap[mutation.node.id];\n\n      if (mutation.previousId || mutation.nextId) {\n        this.legacy_resolveMissingNode(map, parent, node, mutation);\n      }\n    }\n  };\n\n  Replayer.prototype.moveAndHover = function (x, y, id, isSync, debugData) {\n    var target = this.mirror.getNode(id);\n\n    if (!target) {\n      return this.debugNodeNotFound(debugData, id);\n    }\n\n    var base = getBaseDimension(target, this.iframe);\n\n    var _x = x * base.absoluteScale + base.x;\n\n    var _y = y * base.absoluteScale + base.y;\n\n    this.mouse.style.left = \"\".concat(_x, \"px\");\n    this.mouse.style.top = \"\".concat(_y, \"px\");\n\n    if (!isSync) {\n      this.drawMouseTail({\n        x: _x,\n        y: _y\n      });\n    }\n\n    this.hoverElements(target);\n  };\n\n  Replayer.prototype.drawMouseTail = function (position) {\n    var _this = this;\n\n    if (!this.mouseTail) {\n      return;\n    }\n\n    var _a = this.config.mouseTail === true ? defaultMouseTailConfig : Object.assign({}, defaultMouseTailConfig, this.config.mouseTail),\n        lineCap = _a.lineCap,\n        lineWidth = _a.lineWidth,\n        strokeStyle = _a.strokeStyle,\n        duration = _a.duration;\n\n    var draw = function draw() {\n      if (!_this.mouseTail) {\n        return;\n      }\n\n      var ctx = _this.mouseTail.getContext('2d');\n\n      if (!ctx || !_this.tailPositions.length) {\n        return;\n      }\n\n      ctx.clearRect(0, 0, _this.mouseTail.width, _this.mouseTail.height);\n      ctx.beginPath();\n      ctx.lineWidth = lineWidth;\n      ctx.lineCap = lineCap;\n      ctx.strokeStyle = strokeStyle;\n      ctx.moveTo(_this.tailPositions[0].x, _this.tailPositions[0].y);\n\n      _this.tailPositions.forEach(function (p) {\n        return ctx.lineTo(p.x, p.y);\n      });\n\n      ctx.stroke();\n    };\n\n    this.tailPositions.push(position);\n    draw();\n    setTimeout(function () {\n      _this.tailPositions = _this.tailPositions.filter(function (p) {\n        return p !== position;\n      });\n      draw();\n    }, duration / this.speedService.state.context.timer.speed);\n  };\n\n  Replayer.prototype.hoverElements = function (el) {\n    var _a;\n\n    (_a = this.iframe.contentDocument) === null || _a === void 0 ? void 0 : _a.querySelectorAll('.\\\\:hover').forEach(function (hoveredEl) {\n      hoveredEl.classList.remove(':hover');\n    });\n    var currentEl = el;\n\n    while (currentEl) {\n      if (currentEl.classList) {\n        currentEl.classList.add(':hover');\n      }\n\n      currentEl = currentEl.parentElement;\n    }\n  };\n\n  Replayer.prototype.isUserInteraction = function (event) {\n    if (event.type !== EventType.IncrementalSnapshot) {\n      return false;\n    }\n\n    return event.data.source > IncrementalSource.Mutation && event.data.source <= IncrementalSource.Input;\n  };\n\n  Replayer.prototype.backToNormal = function () {\n    this.nextUserInteractionEvent = null;\n\n    if (this.speedService.state.matches('normal')) {\n      return;\n    }\n\n    this.speedService.send({\n      type: 'BACK_TO_NORMAL'\n    });\n    this.emitter.emit(ReplayerEvents.SkipEnd, {\n      speed: this.speedService.state.context.normalSpeed\n    });\n  };\n\n  Replayer.prototype.restoreRealParent = function (frag, parent) {\n    this.mirror.map[parent.__sn.id] = parent;\n\n    if (parent.__sn.type === NodeType.Element && parent.__sn.tagName === 'textarea' && frag.textContent) {\n      parent.value = frag.textContent;\n    }\n\n    parent.appendChild(frag);\n    this.restoreState(parent);\n  };\n\n  Replayer.prototype.storeState = function (parent) {\n    var e_16, _a;\n\n    if (parent) {\n      if (parent.nodeType === parent.ELEMENT_NODE) {\n        var parentElement = parent;\n\n        if (parentElement.scrollLeft || parentElement.scrollTop) {\n          this.elementStateMap.set(parent, {\n            scroll: [parentElement.scrollLeft, parentElement.scrollTop]\n          });\n        }\n\n        if (parentElement.tagName === 'STYLE') storeCSSRules(parentElement, this.virtualStyleRulesMap);\n        var children = parentElement.children;\n\n        try {\n          for (var _b = __values(Array.from(children)), _c = _b.next(); !_c.done; _c = _b.next()) {\n            var child = _c.value;\n            this.storeState(child);\n          }\n        } catch (e_16_1) {\n          e_16 = {\n            error: e_16_1\n          };\n        } finally {\n          try {\n            if (_c && !_c.done && (_a = _b.return)) _a.call(_b);\n          } finally {\n            if (e_16) throw e_16.error;\n          }\n        }\n      }\n    }\n  };\n\n  Replayer.prototype.restoreState = function (parent) {\n    var e_17, _a;\n\n    if (parent.nodeType === parent.ELEMENT_NODE) {\n      var parentElement = parent;\n\n      if (this.elementStateMap.has(parent)) {\n        var storedState = this.elementStateMap.get(parent);\n\n        if (storedState.scroll) {\n          parentElement.scrollLeft = storedState.scroll[0];\n          parentElement.scrollTop = storedState.scroll[1];\n        }\n\n        this.elementStateMap.delete(parent);\n      }\n\n      var children = parentElement.children;\n\n      try {\n        for (var _b = __values(Array.from(children)), _c = _b.next(); !_c.done; _c = _b.next()) {\n          var child = _c.value;\n          this.restoreState(child);\n        }\n      } catch (e_17_1) {\n        e_17 = {\n          error: e_17_1\n        };\n      } finally {\n        try {\n          if (_c && !_c.done && (_a = _b.return)) _a.call(_b);\n        } finally {\n          if (e_17) throw e_17.error;\n        }\n      }\n    }\n  };\n\n  Replayer.prototype.restoreNodeSheet = function (node) {\n    var storedRules = this.virtualStyleRulesMap.get(node);\n\n    if (node.nodeName !== 'STYLE') {\n      return;\n    }\n\n    if (!storedRules) {\n      return;\n    }\n\n    var styleNode = node;\n    applyVirtualStyleRulesToNode(storedRules, styleNode);\n  };\n\n  Replayer.prototype.warnNodeNotFound = function (d, id) {\n    if (this.treeIndex.idRemoved(id)) {\n      this.warn(\"Node with id '\".concat(id, \"' was previously removed. \"), d);\n    } else {\n      this.warn(\"Node with id '\".concat(id, \"' not found. \"), d);\n    }\n  };\n\n  Replayer.prototype.warnCanvasMutationFailed = function (d, error) {\n    this.warn(\"Has error on canvas update\", error, 'canvas mutation:', d);\n  };\n\n  Replayer.prototype.debugNodeNotFound = function (d, id) {\n    if (this.treeIndex.idRemoved(id)) {\n      this.debug(REPLAY_CONSOLE_PREFIX, \"Node with id '\".concat(id, \"' was previously removed. \"), d);\n    } else {\n      this.debug(REPLAY_CONSOLE_PREFIX, \"Node with id '\".concat(id, \"' not found. \"), d);\n    }\n  };\n\n  Replayer.prototype.warn = function () {\n    var args = [];\n\n    for (var _i = 0; _i < arguments.length; _i++) {\n      args[_i] = arguments[_i];\n    }\n\n    if (!this.config.showWarning) {\n      return;\n    }\n\n    console.warn.apply(console, __spreadArray([REPLAY_CONSOLE_PREFIX], __read(args), false));\n  };\n\n  Replayer.prototype.debug = function () {\n    var args = [];\n\n    for (var _i = 0; _i < arguments.length; _i++) {\n      args[_i] = arguments[_i];\n    }\n\n    if (!this.config.showDebug) {\n      return;\n    }\n\n    console.log.apply(console, __spreadArray([REPLAY_CONSOLE_PREFIX], __read(args), false));\n  };\n\n  return Replayer;\n}();\n\nexport { Replayer };","map":null,"metadata":{},"sourceType":"module"}