{"ast":null,"code":"function polyfill(w, d) {\n  if (w === void 0) {\n    w = window;\n  }\n\n  if (d === void 0) {\n    d = document;\n  }\n\n  if ('scrollBehavior' in d.documentElement.style && w.__forceSmoothScrollPolyfill__ !== true) {\n    return;\n  }\n\n  var Element = w.HTMLElement || w.Element;\n  var SCROLL_TIME = 468;\n  var original = {\n    scroll: w.scroll || w.scrollTo,\n    scrollBy: w.scrollBy,\n    elementScroll: Element.prototype.scroll || scrollElement,\n    scrollIntoView: Element.prototype.scrollIntoView\n  };\n  var now = w.performance && w.performance.now ? w.performance.now.bind(w.performance) : Date.now;\n\n  function isMicrosoftBrowser(userAgent) {\n    var userAgentPatterns = ['MSIE ', 'Trident/', 'Edge/'];\n    return new RegExp(userAgentPatterns.join('|')).test(userAgent);\n  }\n\n  var ROUNDING_TOLERANCE = isMicrosoftBrowser(w.navigator.userAgent) ? 1 : 0;\n\n  function scrollElement(x, y) {\n    this.scrollLeft = x;\n    this.scrollTop = y;\n  }\n\n  function ease(k) {\n    return 0.5 * (1 - Math.cos(Math.PI * k));\n  }\n\n  function shouldBailOut(firstArg) {\n    if (firstArg === null || typeof firstArg !== 'object' || firstArg.behavior === undefined || firstArg.behavior === 'auto' || firstArg.behavior === 'instant') {\n      return true;\n    }\n\n    if (typeof firstArg === 'object' && firstArg.behavior === 'smooth') {\n      return false;\n    }\n\n    throw new TypeError('behavior member of ScrollOptions ' + firstArg.behavior + ' is not a valid value for enumeration ScrollBehavior.');\n  }\n\n  function hasScrollableSpace(el, axis) {\n    if (axis === 'Y') {\n      return el.clientHeight + ROUNDING_TOLERANCE < el.scrollHeight;\n    }\n\n    if (axis === 'X') {\n      return el.clientWidth + ROUNDING_TOLERANCE < el.scrollWidth;\n    }\n  }\n\n  function canOverflow(el, axis) {\n    var overflowValue = w.getComputedStyle(el, null)['overflow' + axis];\n    return overflowValue === 'auto' || overflowValue === 'scroll';\n  }\n\n  function isScrollable(el) {\n    var isScrollableY = hasScrollableSpace(el, 'Y') && canOverflow(el, 'Y');\n    var isScrollableX = hasScrollableSpace(el, 'X') && canOverflow(el, 'X');\n    return isScrollableY || isScrollableX;\n  }\n\n  function findScrollableParent(el) {\n    while (el !== d.body && isScrollable(el) === false) {\n      el = el.parentNode || el.host;\n    }\n\n    return el;\n  }\n\n  function step(context) {\n    var time = now();\n    var value;\n    var currentX;\n    var currentY;\n    var elapsed = (time - context.startTime) / SCROLL_TIME;\n    elapsed = elapsed > 1 ? 1 : elapsed;\n    value = ease(elapsed);\n    currentX = context.startX + (context.x - context.startX) * value;\n    currentY = context.startY + (context.y - context.startY) * value;\n    context.method.call(context.scrollable, currentX, currentY);\n\n    if (currentX !== context.x || currentY !== context.y) {\n      w.requestAnimationFrame(step.bind(w, context));\n    }\n  }\n\n  function smoothScroll(el, x, y) {\n    var scrollable;\n    var startX;\n    var startY;\n    var method;\n    var startTime = now();\n\n    if (el === d.body) {\n      scrollable = w;\n      startX = w.scrollX || w.pageXOffset;\n      startY = w.scrollY || w.pageYOffset;\n      method = original.scroll;\n    } else {\n      scrollable = el;\n      startX = el.scrollLeft;\n      startY = el.scrollTop;\n      method = scrollElement;\n    }\n\n    step({\n      scrollable: scrollable,\n      method: method,\n      startTime: startTime,\n      startX: startX,\n      startY: startY,\n      x: x,\n      y: y\n    });\n  }\n\n  w.scroll = w.scrollTo = function () {\n    if (arguments[0] === undefined) {\n      return;\n    }\n\n    if (shouldBailOut(arguments[0]) === true) {\n      original.scroll.call(w, arguments[0].left !== undefined ? arguments[0].left : typeof arguments[0] !== 'object' ? arguments[0] : w.scrollX || w.pageXOffset, arguments[0].top !== undefined ? arguments[0].top : arguments[1] !== undefined ? arguments[1] : w.scrollY || w.pageYOffset);\n      return;\n    }\n\n    smoothScroll.call(w, d.body, arguments[0].left !== undefined ? ~~arguments[0].left : w.scrollX || w.pageXOffset, arguments[0].top !== undefined ? ~~arguments[0].top : w.scrollY || w.pageYOffset);\n  };\n\n  w.scrollBy = function () {\n    if (arguments[0] === undefined) {\n      return;\n    }\n\n    if (shouldBailOut(arguments[0])) {\n      original.scrollBy.call(w, arguments[0].left !== undefined ? arguments[0].left : typeof arguments[0] !== 'object' ? arguments[0] : 0, arguments[0].top !== undefined ? arguments[0].top : arguments[1] !== undefined ? arguments[1] : 0);\n      return;\n    }\n\n    smoothScroll.call(w, d.body, ~~arguments[0].left + (w.scrollX || w.pageXOffset), ~~arguments[0].top + (w.scrollY || w.pageYOffset));\n  };\n\n  Element.prototype.scroll = Element.prototype.scrollTo = function () {\n    if (arguments[0] === undefined) {\n      return;\n    }\n\n    if (shouldBailOut(arguments[0]) === true) {\n      if (typeof arguments[0] === 'number' && arguments[1] === undefined) {\n        throw new SyntaxError('Value could not be converted');\n      }\n\n      original.elementScroll.call(this, arguments[0].left !== undefined ? ~~arguments[0].left : typeof arguments[0] !== 'object' ? ~~arguments[0] : this.scrollLeft, arguments[0].top !== undefined ? ~~arguments[0].top : arguments[1] !== undefined ? ~~arguments[1] : this.scrollTop);\n      return;\n    }\n\n    var left = arguments[0].left;\n    var top = arguments[0].top;\n    smoothScroll.call(this, this, typeof left === 'undefined' ? this.scrollLeft : ~~left, typeof top === 'undefined' ? this.scrollTop : ~~top);\n  };\n\n  Element.prototype.scrollBy = function () {\n    if (arguments[0] === undefined) {\n      return;\n    }\n\n    if (shouldBailOut(arguments[0]) === true) {\n      original.elementScroll.call(this, arguments[0].left !== undefined ? ~~arguments[0].left + this.scrollLeft : ~~arguments[0] + this.scrollLeft, arguments[0].top !== undefined ? ~~arguments[0].top + this.scrollTop : ~~arguments[1] + this.scrollTop);\n      return;\n    }\n\n    this.scroll({\n      left: ~~arguments[0].left + this.scrollLeft,\n      top: ~~arguments[0].top + this.scrollTop,\n      behavior: arguments[0].behavior\n    });\n  };\n\n  Element.prototype.scrollIntoView = function () {\n    if (shouldBailOut(arguments[0]) === true) {\n      original.scrollIntoView.call(this, arguments[0] === undefined ? true : arguments[0]);\n      return;\n    }\n\n    var scrollableParent = findScrollableParent(this);\n    var parentRects = scrollableParent.getBoundingClientRect();\n    var clientRects = this.getBoundingClientRect();\n\n    if (scrollableParent !== d.body) {\n      smoothScroll.call(this, scrollableParent, scrollableParent.scrollLeft + clientRects.left - parentRects.left, scrollableParent.scrollTop + clientRects.top - parentRects.top);\n\n      if (w.getComputedStyle(scrollableParent).position !== 'fixed') {\n        w.scrollBy({\n          left: parentRects.left,\n          top: parentRects.top,\n          behavior: 'smooth'\n        });\n      }\n    } else {\n      w.scrollBy({\n        left: clientRects.left,\n        top: clientRects.top,\n        behavior: 'smooth'\n      });\n    }\n  };\n}\n\nexport { polyfill };","map":null,"metadata":{},"sourceType":"module"}