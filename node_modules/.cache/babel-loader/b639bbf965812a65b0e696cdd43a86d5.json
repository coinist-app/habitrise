{"ast":null,"code":"import { __values } from '../../../../ext/tslib/tslib.es6.js';\n\nfunction pathToSelector(node) {\n  if (!node || !node.outerHTML) {\n    return '';\n  }\n\n  var path = '';\n\n  while (node.parentElement) {\n    var name_1 = node.localName;\n\n    if (!name_1) {\n      break;\n    }\n\n    name_1 = name_1.toLowerCase();\n    var parent_1 = node.parentElement;\n    var domSiblings = [];\n\n    if (parent_1.children && parent_1.children.length > 0) {\n      for (var i = 0; i < parent_1.children.length; i++) {\n        var sibling = parent_1.children[i];\n\n        if (sibling.localName && sibling.localName.toLowerCase) {\n          if (sibling.localName.toLowerCase() === name_1) {\n            domSiblings.push(sibling);\n          }\n        }\n      }\n    }\n\n    if (domSiblings.length > 1) {\n      name_1 += ':eq(' + domSiblings.indexOf(node) + ')';\n    }\n\n    path = name_1 + (path ? '>' + path : '');\n    node = parent_1;\n  }\n\n  return path;\n}\n\nfunction isObject(obj) {\n  return Object.prototype.toString.call(obj) === '[object Object]';\n}\n\nfunction isObjTooDeep(obj, limit) {\n  var e_1, _a;\n\n  if (limit === 0) {\n    return true;\n  }\n\n  var keys = Object.keys(obj);\n\n  try {\n    for (var keys_1 = __values(keys), keys_1_1 = keys_1.next(); !keys_1_1.done; keys_1_1 = keys_1.next()) {\n      var key = keys_1_1.value;\n\n      if (isObject(obj[key]) && isObjTooDeep(obj[key], limit - 1)) {\n        return true;\n      }\n    }\n  } catch (e_1_1) {\n    e_1 = {\n      error: e_1_1\n    };\n  } finally {\n    try {\n      if (keys_1_1 && !keys_1_1.done && (_a = keys_1.return)) _a.call(keys_1);\n    } finally {\n      if (e_1) throw e_1.error;\n    }\n  }\n\n  return false;\n}\n\nfunction stringify(obj, stringifyOptions) {\n  var options = {\n    numOfKeysLimit: 50,\n    depthOfLimit: 4\n  };\n  Object.assign(options, stringifyOptions);\n  var stack = [];\n  var keys = [];\n  return JSON.stringify(obj, function (key, value) {\n    if (stack.length > 0) {\n      var thisPos = stack.indexOf(this);\n      ~thisPos ? stack.splice(thisPos + 1) : stack.push(this);\n      ~thisPos ? keys.splice(thisPos, Infinity, key) : keys.push(key);\n\n      if (~stack.indexOf(value)) {\n        if (stack[0] === value) {\n          value = '[Circular ~]';\n        } else {\n          value = '[Circular ~.' + keys.slice(0, stack.indexOf(value)).join('.') + ']';\n        }\n      }\n    } else {\n      stack.push(value);\n    }\n\n    if (value === null || value === undefined) {\n      return value;\n    }\n\n    if (shouldIgnore(value)) {\n      return toString(value);\n    }\n\n    if (value instanceof Event) {\n      var eventResult = {};\n\n      for (var eventKey in value) {\n        var eventValue = value[eventKey];\n\n        if (Array.isArray(eventValue)) {\n          eventResult[eventKey] = pathToSelector(eventValue.length ? eventValue[0] : null);\n        } else {\n          eventResult[eventKey] = eventValue;\n        }\n      }\n\n      return eventResult;\n    } else if (value instanceof Node) {\n      if (value instanceof HTMLElement) {\n        return value ? value.outerHTML : '';\n      }\n\n      return value.nodeName;\n    } else if (value instanceof Error) {\n      return value.stack ? value.stack + '\\nEnd of stack for Error object' : value.name + ': ' + value.message;\n    }\n\n    return value;\n  });\n\n  function shouldIgnore(_obj) {\n    if (isObject(_obj) && Object.keys(_obj).length > options.numOfKeysLimit) {\n      return true;\n    }\n\n    if (typeof _obj === 'function') {\n      return true;\n    }\n\n    if (isObject(_obj) && isObjTooDeep(_obj, options.depthOfLimit)) {\n      return true;\n    }\n\n    return false;\n  }\n\n  function toString(_obj) {\n    var str = _obj.toString();\n\n    if (options.stringLengthLimit && str.length > options.stringLengthLimit) {\n      str = \"\".concat(str.slice(0, options.stringLengthLimit), \"...\");\n    }\n\n    return str;\n  }\n}\n\nexport { stringify };","map":null,"metadata":{},"sourceType":"module"}