{"ast":null,"code":"import { __rest } from '../../../../ext/tslib/tslib.es6.js';\nimport initCanvas2DMutationObserver from './2d.js';\nimport initCanvasContextObserver from './canvas.js';\nimport initCanvasWebGLMutationObserver from './webgl.js';\n\nvar CanvasManager = function () {\n  function CanvasManager(options) {\n    this.pendingCanvasMutations = new Map();\n    this.rafStamps = {\n      latestId: 0,\n      invokeId: null\n    };\n    this.frozen = false;\n    this.locked = false;\n\n    this.processMutation = function (target, mutation) {\n      var newFrame = this.rafStamps.invokeId && this.rafStamps.latestId !== this.rafStamps.invokeId;\n      if (newFrame || !this.rafStamps.invokeId) this.rafStamps.invokeId = this.rafStamps.latestId;\n\n      if (!this.pendingCanvasMutations.has(target)) {\n        this.pendingCanvasMutations.set(target, []);\n      }\n\n      this.pendingCanvasMutations.get(target).push(mutation);\n    };\n\n    this.mutationCb = options.mutationCb;\n    this.mirror = options.mirror;\n    if (options.recordCanvas === true) this.initCanvasMutationObserver(options.win, options.blockClass);\n  }\n\n  CanvasManager.prototype.reset = function () {\n    this.pendingCanvasMutations.clear();\n    this.resetObservers && this.resetObservers();\n  };\n\n  CanvasManager.prototype.freeze = function () {\n    this.frozen = true;\n  };\n\n  CanvasManager.prototype.unfreeze = function () {\n    this.frozen = false;\n  };\n\n  CanvasManager.prototype.lock = function () {\n    this.locked = true;\n  };\n\n  CanvasManager.prototype.unlock = function () {\n    this.locked = false;\n  };\n\n  CanvasManager.prototype.initCanvasMutationObserver = function (win, blockClass) {\n    this.startRAFTimestamping();\n    this.startPendingCanvasMutationFlusher();\n    var canvasContextReset = initCanvasContextObserver(win, blockClass);\n    var canvas2DReset = initCanvas2DMutationObserver(this.processMutation.bind(this), win, blockClass, this.mirror);\n    var canvasWebGL1and2Reset = initCanvasWebGLMutationObserver(this.processMutation.bind(this), win, blockClass, this.mirror);\n\n    this.resetObservers = function () {\n      canvasContextReset();\n      canvas2DReset();\n      canvasWebGL1and2Reset();\n    };\n  };\n\n  CanvasManager.prototype.startPendingCanvasMutationFlusher = function () {\n    var _this = this;\n\n    requestAnimationFrame(function () {\n      return _this.flushPendingCanvasMutations();\n    });\n  };\n\n  CanvasManager.prototype.startRAFTimestamping = function () {\n    var _this = this;\n\n    var setLatestRAFTimestamp = function setLatestRAFTimestamp(timestamp) {\n      _this.rafStamps.latestId = timestamp;\n      requestAnimationFrame(setLatestRAFTimestamp);\n    };\n\n    requestAnimationFrame(setLatestRAFTimestamp);\n  };\n\n  CanvasManager.prototype.flushPendingCanvasMutations = function () {\n    var _this = this;\n\n    this.pendingCanvasMutations.forEach(function (values, canvas) {\n      var id = _this.mirror.getId(canvas);\n\n      _this.flushPendingCanvasMutationFor(canvas, id);\n    });\n    requestAnimationFrame(function () {\n      return _this.flushPendingCanvasMutations();\n    });\n  };\n\n  CanvasManager.prototype.flushPendingCanvasMutationFor = function (canvas, id) {\n    if (this.frozen || this.locked) {\n      return;\n    }\n\n    var valuesWithType = this.pendingCanvasMutations.get(canvas);\n    if (!valuesWithType || id === -1) return;\n    var values = valuesWithType.map(function (value) {\n      value.type;\n\n      var rest = __rest(value, [\"type\"]);\n\n      return rest;\n    });\n    var type = valuesWithType[0].type;\n    this.mutationCb({\n      id: id,\n      type: type,\n      commands: values\n    });\n    this.pendingCanvasMutations.delete(canvas);\n  };\n\n  return CanvasManager;\n}();\n\nexport { CanvasManager };","map":null,"metadata":{},"sourceType":"module"}