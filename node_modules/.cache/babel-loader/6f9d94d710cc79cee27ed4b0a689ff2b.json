{"ast":null,"code":"import { __values, __spreadArray, __read } from '../../../../ext/tslib/tslib.es6.js';\nimport { patch } from '../../../utils.js';\nimport { ErrorStackParser } from './error-stack-parser.js';\nimport { stringify } from './stringify.js';\nvar defaultLogOptions = {\n  level: ['assert', 'clear', 'count', 'countReset', 'debug', 'dir', 'dirxml', 'error', 'group', 'groupCollapsed', 'groupEnd', 'info', 'log', 'table', 'time', 'timeEnd', 'timeLog', 'trace', 'warn'],\n  lengthThreshold: 1000,\n  logger: 'console'\n};\n\nfunction initLogObserver(cb, win, logOptions) {\n  var e_1, _a;\n\n  var loggerType = logOptions.logger;\n\n  if (!loggerType) {\n    return function () {};\n  }\n\n  var logger;\n\n  if (typeof loggerType === 'string') {\n    logger = win[loggerType];\n  } else {\n    logger = loggerType;\n  }\n\n  var logCount = 0;\n  var cancelHandlers = [];\n\n  if (logOptions.level.includes('error')) {\n    if (window) {\n      var errorHandler_1 = function errorHandler_1(event) {\n        var message = event.message,\n            error = event.error;\n        var trace = ErrorStackParser.parse(error).map(function (stackFrame) {\n          return stackFrame.toString();\n        });\n        var payload = [stringify(message, logOptions.stringifyOptions)];\n        cb({\n          level: 'error',\n          trace: trace,\n          payload: payload\n        });\n      };\n\n      window.addEventListener('error', errorHandler_1);\n      cancelHandlers.push(function () {\n        if (window) window.removeEventListener('error', errorHandler_1);\n      });\n    }\n  }\n\n  try {\n    for (var _b = __values(logOptions.level), _c = _b.next(); !_c.done; _c = _b.next()) {\n      var levelType = _c.value;\n      cancelHandlers.push(replace(logger, levelType));\n    }\n  } catch (e_1_1) {\n    e_1 = {\n      error: e_1_1\n    };\n  } finally {\n    try {\n      if (_c && !_c.done && (_a = _b.return)) _a.call(_b);\n    } finally {\n      if (e_1) throw e_1.error;\n    }\n  }\n\n  return function () {\n    cancelHandlers.forEach(function (h) {\n      return h();\n    });\n  };\n\n  function replace(_logger, level) {\n    var _this = this;\n\n    if (!_logger[level]) {\n      return function () {};\n    }\n\n    return patch(_logger, level, function (original) {\n      return function () {\n        var args = [];\n\n        for (var _i = 0; _i < arguments.length; _i++) {\n          args[_i] = arguments[_i];\n        }\n\n        original.apply(_this, args);\n\n        try {\n          var trace = ErrorStackParser.parse(new Error()).map(function (stackFrame) {\n            return stackFrame.toString();\n          }).splice(1);\n          var payload = args.map(function (s) {\n            return stringify(s, logOptions.stringifyOptions);\n          });\n          logCount++;\n\n          if (logCount < logOptions.lengthThreshold) {\n            cb({\n              level: level,\n              trace: trace,\n              payload: payload\n            });\n          } else if (logCount === logOptions.lengthThreshold) {\n            cb({\n              level: 'warn',\n              trace: [],\n              payload: [stringify('The number of log records reached the threshold.')]\n            });\n          }\n        } catch (error) {\n          original.apply(void 0, __spreadArray(['rrweb logger error:', error], __read(args), false));\n        }\n      };\n    });\n  }\n}\n\nvar PLUGIN_NAME = 'rrweb/console@1';\n\nvar getRecordConsolePlugin = function getRecordConsolePlugin(options) {\n  return {\n    name: PLUGIN_NAME,\n    observer: initLogObserver,\n    options: options ? Object.assign({}, defaultLogOptions, options) : defaultLogOptions\n  };\n};\n\nexport { PLUGIN_NAME, getRecordConsolePlugin };","map":null,"metadata":{},"sourceType":"module"}