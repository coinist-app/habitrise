{"ast":null,"code":"import { __values } from '../../ext/tslib/tslib.es6.js';\nimport { isShadowRoot, maskInputValue, transformAttribute, needMaskingText, IGNORED_NODE, serializeNodeWithId } from '../../../rrweb-snapshot/es/rrweb-snapshot.js';\nimport { isIgnored, isBlocked, isAncestorRemoved, isIframeINode, hasShadowRoot } from '../utils.js';\n\nfunction isNodeInLinkedList(n) {\n  return '__ln' in n;\n}\n\nvar DoubleLinkedList = function () {\n  function DoubleLinkedList() {\n    this.length = 0;\n    this.head = null;\n  }\n\n  DoubleLinkedList.prototype.get = function (position) {\n    if (position >= this.length) {\n      throw new Error('Position outside of list range');\n    }\n\n    var current = this.head;\n\n    for (var index = 0; index < position; index++) {\n      current = (current === null || current === void 0 ? void 0 : current.next) || null;\n    }\n\n    return current;\n  };\n\n  DoubleLinkedList.prototype.addNode = function (n) {\n    var node = {\n      value: n,\n      previous: null,\n      next: null\n    };\n    n.__ln = node;\n\n    if (n.previousSibling && isNodeInLinkedList(n.previousSibling)) {\n      var current = n.previousSibling.__ln.next;\n      node.next = current;\n      node.previous = n.previousSibling.__ln;\n      n.previousSibling.__ln.next = node;\n\n      if (current) {\n        current.previous = node;\n      }\n    } else if (n.nextSibling && isNodeInLinkedList(n.nextSibling) && n.nextSibling.__ln.previous) {\n      var current = n.nextSibling.__ln.previous;\n      node.previous = current;\n      node.next = n.nextSibling.__ln;\n      n.nextSibling.__ln.previous = node;\n\n      if (current) {\n        current.next = node;\n      }\n    } else {\n      if (this.head) {\n        this.head.previous = node;\n      }\n\n      node.next = this.head;\n      this.head = node;\n    }\n\n    this.length++;\n  };\n\n  DoubleLinkedList.prototype.removeNode = function (n) {\n    var current = n.__ln;\n\n    if (!this.head) {\n      return;\n    }\n\n    if (!current.previous) {\n      this.head = current.next;\n\n      if (this.head) {\n        this.head.previous = null;\n      }\n    } else {\n      current.previous.next = current.next;\n\n      if (current.next) {\n        current.next.previous = current.previous;\n      }\n    }\n\n    if (n.__ln) {\n      delete n.__ln;\n    }\n\n    this.length--;\n  };\n\n  return DoubleLinkedList;\n}();\n\nvar moveKey = function moveKey(id, parentId) {\n  return \"\".concat(id, \"@\").concat(parentId);\n};\n\nfunction isINode(n) {\n  return '__sn' in n;\n}\n\nvar MutationBuffer = function () {\n  function MutationBuffer() {\n    var _this = this;\n\n    this.frozen = false;\n    this.locked = false;\n    this.texts = [];\n    this.attributes = [];\n    this.removes = [];\n    this.mapRemoves = [];\n    this.movedMap = {};\n    this.addedSet = new Set();\n    this.movedSet = new Set();\n    this.droppedSet = new Set();\n\n    this.processMutations = function (mutations) {\n      mutations.forEach(_this.processMutation);\n\n      _this.emit();\n    };\n\n    this.emit = function () {\n      var e_1, _a, e_2, _b;\n\n      if (_this.frozen || _this.locked) {\n        return;\n      }\n\n      var adds = [];\n      var addList = new DoubleLinkedList();\n\n      var getNextId = function getNextId(n) {\n        var ns = n;\n        var nextId = IGNORED_NODE;\n\n        while (nextId === IGNORED_NODE) {\n          ns = ns && ns.nextSibling;\n          nextId = ns && _this.mirror.getId(ns);\n        }\n\n        return nextId;\n      };\n\n      var pushAdd = function pushAdd(n) {\n        var _a, _b, _c, _d, _e;\n\n        var shadowHost = n.getRootNode ? (_a = n.getRootNode()) === null || _a === void 0 ? void 0 : _a.host : null;\n        var rootShadowHost = shadowHost;\n\n        while ((_c = (_b = rootShadowHost === null || rootShadowHost === void 0 ? void 0 : rootShadowHost.getRootNode) === null || _b === void 0 ? void 0 : _b.call(rootShadowHost)) === null || _c === void 0 ? void 0 : _c.host) {\n          rootShadowHost = ((_e = (_d = rootShadowHost === null || rootShadowHost === void 0 ? void 0 : rootShadowHost.getRootNode) === null || _d === void 0 ? void 0 : _d.call(rootShadowHost)) === null || _e === void 0 ? void 0 : _e.host) || null;\n        }\n\n        var notInDoc = !_this.doc.contains(n) && (rootShadowHost === null || !_this.doc.contains(rootShadowHost));\n\n        if (!n.parentNode || notInDoc) {\n          return;\n        }\n\n        var parentId = isShadowRoot(n.parentNode) ? _this.mirror.getId(shadowHost) : _this.mirror.getId(n.parentNode);\n        var nextId = getNextId(n);\n\n        if (parentId === -1 || nextId === -1) {\n          return addList.addNode(n);\n        }\n\n        var sn = serializeNodeWithId(n, {\n          doc: _this.doc,\n          map: _this.mirror.map,\n          blockClass: _this.blockClass,\n          blockSelector: _this.blockSelector,\n          maskTextClass: _this.maskTextClass,\n          maskTextSelector: _this.maskTextSelector,\n          skipChild: true,\n          inlineStylesheet: _this.inlineStylesheet,\n          maskInputOptions: _this.maskInputOptions,\n          maskTextFn: _this.maskTextFn,\n          maskInputFn: _this.maskInputFn,\n          slimDOMOptions: _this.slimDOMOptions,\n          recordCanvas: _this.recordCanvas,\n          inlineImages: _this.inlineImages,\n          onSerialize: function onSerialize(currentN) {\n            if (isIframeINode(currentN)) {\n              _this.iframeManager.addIframe(currentN);\n            }\n\n            if (hasShadowRoot(n)) {\n              _this.shadowDomManager.addShadowRoot(n.shadowRoot, document);\n            }\n          },\n          onIframeLoad: function onIframeLoad(iframe, childSn) {\n            _this.iframeManager.attachIframe(iframe, childSn);\n\n            _this.shadowDomManager.observeAttachShadow(iframe);\n          }\n        });\n\n        if (sn) {\n          adds.push({\n            parentId: parentId,\n            nextId: nextId,\n            node: sn\n          });\n        }\n      };\n\n      while (_this.mapRemoves.length) {\n        _this.mirror.removeNodeFromMap(_this.mapRemoves.shift());\n      }\n\n      try {\n        for (var _c = __values(_this.movedSet), _d = _c.next(); !_d.done; _d = _c.next()) {\n          var n = _d.value;\n\n          if (isParentRemoved(_this.removes, n, _this.mirror) && !_this.movedSet.has(n.parentNode)) {\n            continue;\n          }\n\n          pushAdd(n);\n        }\n      } catch (e_1_1) {\n        e_1 = {\n          error: e_1_1\n        };\n      } finally {\n        try {\n          if (_d && !_d.done && (_a = _c.return)) _a.call(_c);\n        } finally {\n          if (e_1) throw e_1.error;\n        }\n      }\n\n      try {\n        for (var _e = __values(_this.addedSet), _f = _e.next(); !_f.done; _f = _e.next()) {\n          var n = _f.value;\n\n          if (!isAncestorInSet(_this.droppedSet, n) && !isParentRemoved(_this.removes, n, _this.mirror)) {\n            pushAdd(n);\n          } else if (isAncestorInSet(_this.movedSet, n)) {\n            pushAdd(n);\n          } else {\n            _this.droppedSet.add(n);\n          }\n        }\n      } catch (e_2_1) {\n        e_2 = {\n          error: e_2_1\n        };\n      } finally {\n        try {\n          if (_f && !_f.done && (_b = _e.return)) _b.call(_e);\n        } finally {\n          if (e_2) throw e_2.error;\n        }\n      }\n\n      var candidate = null;\n\n      while (addList.length) {\n        var node = null;\n\n        if (candidate) {\n          var parentId = _this.mirror.getId(candidate.value.parentNode);\n\n          var nextId = getNextId(candidate.value);\n\n          if (parentId !== -1 && nextId !== -1) {\n            node = candidate;\n          }\n        }\n\n        if (!node) {\n          for (var index = addList.length - 1; index >= 0; index--) {\n            var _node = addList.get(index);\n\n            if (_node) {\n              var parentId = _this.mirror.getId(_node.value.parentNode);\n\n              var nextId = getNextId(_node.value);\n\n              if (parentId !== -1 && nextId !== -1) {\n                node = _node;\n                break;\n              }\n            }\n          }\n        }\n\n        if (!node) {\n          while (addList.head) {\n            addList.removeNode(addList.head.value);\n          }\n\n          break;\n        }\n\n        candidate = node.previous;\n        addList.removeNode(node.value);\n        pushAdd(node.value);\n      }\n\n      var payload = {\n        texts: _this.texts.map(function (text) {\n          return {\n            id: _this.mirror.getId(text.node),\n            value: text.value\n          };\n        }).filter(function (text) {\n          return _this.mirror.has(text.id);\n        }),\n        attributes: _this.attributes.map(function (attribute) {\n          return {\n            id: _this.mirror.getId(attribute.node),\n            attributes: attribute.attributes\n          };\n        }).filter(function (attribute) {\n          return _this.mirror.has(attribute.id);\n        }),\n        removes: _this.removes,\n        adds: adds\n      };\n\n      if (!payload.texts.length && !payload.attributes.length && !payload.removes.length && !payload.adds.length) {\n        return;\n      }\n\n      _this.texts = [];\n      _this.attributes = [];\n      _this.removes = [];\n      _this.addedSet = new Set();\n      _this.movedSet = new Set();\n      _this.droppedSet = new Set();\n      _this.movedMap = {};\n\n      _this.mutationCb(payload);\n    };\n\n    this.processMutation = function (m) {\n      var e_3, _a, e_4, _b;\n\n      if (isIgnored(m.target)) {\n        return;\n      }\n\n      switch (m.type) {\n        case 'characterData':\n          {\n            var value = m.target.textContent;\n\n            if (!isBlocked(m.target, _this.blockClass) && value !== m.oldValue) {\n              _this.texts.push({\n                value: needMaskingText(m.target, _this.maskTextClass, _this.maskTextSelector) && value ? _this.maskTextFn ? _this.maskTextFn(value) : value.replace(/[\\S]/g, '*') : value,\n                node: m.target\n              });\n            }\n\n            break;\n          }\n\n        case 'attributes':\n          {\n            var target = m.target;\n            var value = m.target.getAttribute(m.attributeName);\n\n            if (m.attributeName === 'value') {\n              value = maskInputValue({\n                maskInputOptions: _this.maskInputOptions,\n                tagName: m.target.tagName,\n                type: m.target.getAttribute('type'),\n                value: value,\n                maskInputFn: _this.maskInputFn\n              });\n            }\n\n            if (isBlocked(m.target, _this.blockClass) || value === m.oldValue) {\n              return;\n            }\n\n            var item = _this.attributes.find(function (a) {\n              return a.node === m.target;\n            });\n\n            if (!item) {\n              item = {\n                node: m.target,\n                attributes: {}\n              };\n\n              _this.attributes.push(item);\n            }\n\n            if (m.attributeName === 'style') {\n              var old = _this.doc.createElement('span');\n\n              if (m.oldValue) {\n                old.setAttribute('style', m.oldValue);\n              }\n\n              if (item.attributes.style === undefined || item.attributes.style === null) {\n                item.attributes.style = {};\n              }\n\n              var styleObj = item.attributes.style;\n\n              try {\n                for (var _c = __values(Array.from(target.style)), _d = _c.next(); !_d.done; _d = _c.next()) {\n                  var pname = _d.value;\n                  var newValue = target.style.getPropertyValue(pname);\n                  var newPriority = target.style.getPropertyPriority(pname);\n\n                  if (newValue !== old.style.getPropertyValue(pname) || newPriority !== old.style.getPropertyPriority(pname)) {\n                    if (newPriority === '') {\n                      styleObj[pname] = newValue;\n                    } else {\n                      styleObj[pname] = [newValue, newPriority];\n                    }\n                  }\n                }\n              } catch (e_3_1) {\n                e_3 = {\n                  error: e_3_1\n                };\n              } finally {\n                try {\n                  if (_d && !_d.done && (_a = _c.return)) _a.call(_c);\n                } finally {\n                  if (e_3) throw e_3.error;\n                }\n              }\n\n              try {\n                for (var _e = __values(Array.from(old.style)), _f = _e.next(); !_f.done; _f = _e.next()) {\n                  var pname = _f.value;\n\n                  if (target.style.getPropertyValue(pname) === '') {\n                    styleObj[pname] = false;\n                  }\n                }\n              } catch (e_4_1) {\n                e_4 = {\n                  error: e_4_1\n                };\n              } finally {\n                try {\n                  if (_f && !_f.done && (_b = _e.return)) _b.call(_e);\n                } finally {\n                  if (e_4) throw e_4.error;\n                }\n              }\n            } else {\n              item.attributes[m.attributeName] = transformAttribute(_this.doc, m.target.tagName, m.attributeName, value);\n            }\n\n            break;\n          }\n\n        case 'childList':\n          {\n            m.addedNodes.forEach(function (n) {\n              return _this.genAdds(n, m.target);\n            });\n            m.removedNodes.forEach(function (n) {\n              var nodeId = _this.mirror.getId(n);\n\n              var parentId = isShadowRoot(m.target) ? _this.mirror.getId(m.target.host) : _this.mirror.getId(m.target);\n\n              if (isBlocked(m.target, _this.blockClass) || isIgnored(n)) {\n                return;\n              }\n\n              if (_this.addedSet.has(n)) {\n                deepDelete(_this.addedSet, n);\n\n                _this.droppedSet.add(n);\n              } else if (_this.addedSet.has(m.target) && nodeId === -1) ;else if (isAncestorRemoved(m.target, _this.mirror)) ;else if (_this.movedSet.has(n) && _this.movedMap[moveKey(nodeId, parentId)]) {\n                deepDelete(_this.movedSet, n);\n              } else {\n                _this.removes.push({\n                  parentId: parentId,\n                  id: nodeId,\n                  isShadow: isShadowRoot(m.target) ? true : undefined\n                });\n              }\n\n              _this.mapRemoves.push(n);\n            });\n            break;\n          }\n      }\n    };\n\n    this.genAdds = function (n, target) {\n      if (target && isBlocked(target, _this.blockClass)) {\n        return;\n      }\n\n      if (isINode(n)) {\n        if (isIgnored(n)) {\n          return;\n        }\n\n        _this.movedSet.add(n);\n\n        var targetId = null;\n\n        if (target && isINode(target)) {\n          targetId = target.__sn.id;\n        }\n\n        if (targetId) {\n          _this.movedMap[moveKey(n.__sn.id, targetId)] = true;\n        }\n      } else {\n        _this.addedSet.add(n);\n\n        _this.droppedSet.delete(n);\n      }\n\n      if (!isBlocked(n, _this.blockClass)) n.childNodes.forEach(function (childN) {\n        return _this.genAdds(childN);\n      });\n    };\n  }\n\n  MutationBuffer.prototype.init = function (options) {\n    var _this = this;\n\n    ['mutationCb', 'blockClass', 'blockSelector', 'maskTextClass', 'maskTextSelector', 'inlineStylesheet', 'maskInputOptions', 'maskTextFn', 'maskInputFn', 'recordCanvas', 'inlineImages', 'slimDOMOptions', 'doc', 'mirror', 'iframeManager', 'shadowDomManager', 'canvasManager'].forEach(function (key) {\n      _this[key] = options[key];\n    });\n  };\n\n  MutationBuffer.prototype.freeze = function () {\n    this.frozen = true;\n    this.canvasManager.freeze();\n  };\n\n  MutationBuffer.prototype.unfreeze = function () {\n    this.frozen = false;\n    this.canvasManager.unfreeze();\n    this.emit();\n  };\n\n  MutationBuffer.prototype.isFrozen = function () {\n    return this.frozen;\n  };\n\n  MutationBuffer.prototype.lock = function () {\n    this.locked = true;\n    this.canvasManager.lock();\n  };\n\n  MutationBuffer.prototype.unlock = function () {\n    this.locked = false;\n    this.canvasManager.unlock();\n    this.emit();\n  };\n\n  MutationBuffer.prototype.reset = function () {\n    this.shadowDomManager.reset();\n    this.canvasManager.reset();\n  };\n\n  return MutationBuffer;\n}();\n\nfunction deepDelete(addsSet, n) {\n  addsSet.delete(n);\n  n.childNodes.forEach(function (childN) {\n    return deepDelete(addsSet, childN);\n  });\n}\n\nfunction isParentRemoved(removes, n, mirror) {\n  var parentNode = n.parentNode;\n\n  if (!parentNode) {\n    return false;\n  }\n\n  var parentId = mirror.getId(parentNode);\n\n  if (removes.some(function (r) {\n    return r.id === parentId;\n  })) {\n    return true;\n  }\n\n  return isParentRemoved(removes, parentNode, mirror);\n}\n\nfunction isAncestorInSet(set, n) {\n  var parentNode = n.parentNode;\n\n  if (!parentNode) {\n    return false;\n  }\n\n  if (set.has(parentNode)) {\n    return true;\n  }\n\n  return isAncestorInSet(set, parentNode);\n}\n\nexport default MutationBuffer;","map":null,"metadata":{},"sourceType":"module"}