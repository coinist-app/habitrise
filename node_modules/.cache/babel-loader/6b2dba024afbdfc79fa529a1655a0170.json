{"ast":null,"code":"\"use strict\";\n\nvar e = require(\"crypto\"),\n    t = function () {\n  function t(r) {\n    var i = this;\n    this.deriveKey = function (r, i) {\n      var n = Object.assign({}, t.defaultDeriveKeyOpts, i),\n          s = n.salt,\n          o = n.iterations,\n          a = n.digest;\n      return e.pbkdf2Sync(r, s, o, 32, a);\n    }, this.encryptString = function (t, r) {\n      var n = i.deriveKey(r, i._deriveKeyOptions),\n          s = e.randomBytes(16),\n          o = e.createCipheriv(\"aes-256-gcm\", n, s),\n          a = o.update(t.toString(), \"utf8\", \"base64\");\n      a += o.final(\"base64\");\n      var f = Buffer.from(a).toString(\"hex\");\n      return s.toString(\"hex\") + \":\" + f;\n    }, this.decryptString = function (t, r) {\n      var n = i.deriveKey(r, i._deriveKeyOptions),\n          s = t.toString().split(\":\");\n      if (2 !== s.length) throw new Error(\"Incorrect format for encrypted string: \" + t);\n      var o = s[0],\n          a = s[1],\n          f = Buffer.from(o, \"hex\"),\n          u = Buffer.from(a, \"hex\").toString();\n      return e.createDecipheriv(\"aes-256-gcm\", n, f).update(u, \"base64\").toString();\n    }, r && (this._deriveKeyOptions = r);\n  }\n\n  return t.defaultDeriveKeyOpts = {\n    salt: \"s41t\",\n    iterations: 1,\n    digest: \"sha512\"\n  }, t;\n}();\n\nmodule.exports = t;","map":{"version":3,"mappings":";;;;EAkBE,WAAYA,CAAZ,EAAYA;IAAZ;IAMAC,iBAAY,UACVC,CADU,EAEVF,CAFU,EAEVA;MAEM,QAIFG,OAAOC,MAAPD,CACF,EADEA,EAEFE,EAAaC,oBAFXH,EAGFH,CAHEG,CAJE;MAAA,IACJI,UADI;MAAA,IAEJC,gBAFI;MAAA,IAGJC,YAHI;MAUN,OAAOC,aAAWR,CAAXQ,EAAqBH,CAArBG,EAA2BF,CAA3BE,EA/BI,EA+BJA,EAA+CD,CAA/CC,CAAP;IAAsDD,CAdxDR,EAiBAA,qBAAgB,UACdU,CADc,EAEdT,CAFc,EAEdA;MAEA,IAAMU,IAAaC,EAAKC,SAALD,CAAeX,CAAfW,EAAyBA,EAAKE,iBAA9BF,CAAnB;MAAA,IAEMG,IAAmBC,cAAY,EAAZA,CAFzB;MAAA,IAIMC,IAASC,iBAAe,aAAfA,EAA8BP,CAA9BO,EAA0CH,CAA1CG,CAJf;MAAA,IAMIC,IAAkBF,EAAOG,MAAPH,CAAcP,EAAIW,QAAJX,EAAdO,EAA8B,MAA9BA,EAAsC,QAAtCA,CANtB;MAOAE,KAAmBF,EAAOK,KAAPL,CAAa,QAAbA,CAAnBE;MAEA,IAAMI,IAAeC,OAAOC,IAAPD,CAAYL,CAAZK,EAA6BH,QAA7BG,CAAsC,KAAtCA,CAArB;MAIA,OAFsBT,EAAiBM,QAAjBN,CAA0B,KAA1BA,IAA0B,GAA1BA,GAEKQ,CAA3B;IAA2BA,CAlC7BvB,EAqCAA,qBAAgB,UACd0B,CADc,EAEdzB,CAFc,EAEdA;MAEA,IAAMU,IAAaC,EAAKC,SAALD,CAAeX,CAAfW,EAAyBA,EAAKE,iBAA9BF,CAAnB;MAAA,IAEMe,IAA2BD,EAAaL,QAAbK,GAAwBE,KAAxBF,CAA8B,GAA9BA,CAFjC;MAIA,IAA8B,MAA1BC,EAAeE,MAAnB,EACE,MAAM,IAAIC,KAAJ,CAAU,4CAA0CJ,CAApD,CAAN;MAIA,QAEEC,IAFF;MAAA,IACAJ,IACEI,IAFF;MAAA,IAIIZ,IAAmBS,OAAOC,IAAPD,CAAYO,CAAZP,EAA2B,KAA3BA,CAJvB;MAAA,IAMIL,IAAkBK,OAAOC,IAAPD,CAAYD,CAAZC,EAA0B,KAA1BA,EAAiCH,QAAjCG,EANtB;MAYF,OAJeQ,mBAAiB,aAAjBA,EAAgCrB,CAAhCqB,EAA4CjB,CAA5CiB,EAEQZ,MAFRY,CAEeb,CAFfa,EAEgC,QAFhCA,EAIEX,QAJFW,EAIf;IAAiBX,CA9DnBrB,EALMD,MACFC,KAAKc,iBAALd,GAAyBD,CADvBA,CAKNC;EAgEF;;EAAA,OA9ESI,yBAAsC;IAC3CE,MAAM,MADqC;IAE3CC,YAAY,CAF+B;IAG3CC,QAAQ;EAHmC,CAAtCJ,EAGG6B,CA2EZ;AA3EY;;AAAAC","names":["options","this","password","Object","assign","StringCrypto","defaultDeriveKeyOpts","salt","iterations","digest","pbkdf2Sync","str","derivedKey","_this","deriveKey","_deriveKeyOptions","randomInitVector","randomBytes","aesCBC","createCipheriv","encryptedBase64","update","toString","final","encryptedHex","Buffer","from","encryptedStr","encryptedParts","split","length","Error","initVectorHex","createDecipheriv","t","module"],"sources":["../src/index.ts"],"sourcesContent":["import {\n  randomBytes,\n  pbkdf2Sync,\n  createCipheriv,\n  createDecipheriv,\n} from 'crypto';\n\nconst KEYLEN = 256 / 8; // Because we use aes-256-gcm\n\nclass StringCrypto {\n  static defaultDeriveKeyOpts: DeriveKeyOpts = {\n    salt: 's41t',\n    iterations: 1,\n    digest: 'sha512',\n  };\n\n  private _deriveKeyOptions: DeriveKeyOpts;\n\n  constructor(options?: DeriveKeyOpts) {\n    if (options) {\n      this._deriveKeyOptions = options;\n    }\n  }\n\n  deriveKey = (\n    password: StringLike,\n    options?: DeriveKeyOpts,\n  ) => {\n    const {\n      salt,\n      iterations,\n      digest,\n    } = Object.assign(\n      {},\n      StringCrypto.defaultDeriveKeyOpts,\n      options,\n    );\n\n    return pbkdf2Sync(password, salt, iterations, KEYLEN, digest);\n  };\n\n  encryptString = (\n    str: StringLike,\n    password: StringLike,\n  ): string => {\n    const derivedKey = this.deriveKey(password, this._deriveKeyOptions);\n\n    const randomInitVector = randomBytes(16);\n\n    const aesCBC = createCipheriv('aes-256-gcm', derivedKey, randomInitVector);\n\n    let encryptedBase64 = aesCBC.update(str.toString(), 'utf8', 'base64');\n    encryptedBase64 += aesCBC.final('base64');\n\n    const encryptedHex = Buffer.from(encryptedBase64).toString('hex');\n\n    const initVectorHex = randomInitVector.toString('hex');\n\n    return `${initVectorHex}:${encryptedHex}`;\n  };\n\n  decryptString = (\n    encryptedStr: StringLike,\n    password: StringLike,\n  ): string => {\n    const derivedKey = this.deriveKey(password, this._deriveKeyOptions);\n\n    const encryptedParts: string[] = encryptedStr.toString().split(':');\n\n    if (encryptedParts.length !== 2) {\n      throw new Error(`Incorrect format for encrypted string: ${encryptedStr}`);\n    }\n\n    const [\n      initVectorHex,\n      encryptedHex,\n    ] = encryptedParts;\n\n    const randomInitVector = Buffer.from(initVectorHex, 'hex');\n\n    const encryptedBase64 = Buffer.from(encryptedHex, 'hex').toString();\n\n    const aesCBC = createDecipheriv('aes-256-gcm', derivedKey, randomInitVector);\n\n    let decrypted = aesCBC.update(encryptedBase64, 'base64');\n\n    return decrypted.toString();\n  };\n}\n\nexport default StringCrypto;\n"]},"metadata":{},"sourceType":"script"}