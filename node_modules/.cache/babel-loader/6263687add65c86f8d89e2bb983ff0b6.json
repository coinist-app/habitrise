{"ast":null,"code":"import { __assign, __values } from '../../ext/tslib/tslib.es6.js';\nimport { interpret as v, createMachine as s, assign as o } from '../../../../ext/@xstate/fsm/es/index.js';\nimport { EventType, IncrementalSource, ReplayerEvents } from '../types.js';\nimport { addDelay } from './timer.js';\n\nfunction discardPriorSnapshots(events, baselineTime) {\n  for (var idx = events.length - 1; idx >= 0; idx--) {\n    var event_1 = events[idx];\n\n    if (event_1.type === EventType.Meta) {\n      if (event_1.timestamp <= baselineTime) {\n        return events.slice(idx);\n      }\n    }\n  }\n\n  return events;\n}\n\nfunction createPlayerService(context, _a) {\n  var getCastFn = _a.getCastFn,\n      applyEventsSynchronously = _a.applyEventsSynchronously,\n      emitter = _a.emitter;\n  var playerMachine = s({\n    id: 'player',\n    context: context,\n    initial: 'paused',\n    states: {\n      playing: {\n        on: {\n          PAUSE: {\n            target: 'paused',\n            actions: ['pause']\n          },\n          CAST_EVENT: {\n            target: 'playing',\n            actions: 'castEvent'\n          },\n          END: {\n            target: 'paused',\n            actions: ['resetLastPlayedEvent', 'pause']\n          },\n          ADD_EVENT: {\n            target: 'playing',\n            actions: ['addEvent']\n          }\n        }\n      },\n      paused: {\n        on: {\n          PLAY: {\n            target: 'playing',\n            actions: ['recordTimeOffset', 'play']\n          },\n          CAST_EVENT: {\n            target: 'paused',\n            actions: 'castEvent'\n          },\n          TO_LIVE: {\n            target: 'live',\n            actions: ['startLive']\n          },\n          ADD_EVENT: {\n            target: 'paused',\n            actions: ['addEvent']\n          }\n        }\n      },\n      live: {\n        on: {\n          ADD_EVENT: {\n            target: 'live',\n            actions: ['addEvent']\n          },\n          CAST_EVENT: {\n            target: 'live',\n            actions: ['castEvent']\n          }\n        }\n      }\n    }\n  }, {\n    actions: {\n      castEvent: o({\n        lastPlayedEvent: function lastPlayedEvent(ctx, event) {\n          if (event.type === 'CAST_EVENT') {\n            return event.payload.event;\n          }\n\n          return ctx.lastPlayedEvent;\n        }\n      }),\n      recordTimeOffset: o(function (ctx, event) {\n        var timeOffset = ctx.timeOffset;\n\n        if ('payload' in event && 'timeOffset' in event.payload) {\n          timeOffset = event.payload.timeOffset;\n        }\n\n        return __assign(__assign({}, ctx), {\n          timeOffset: timeOffset,\n          baselineTime: ctx.events[0].timestamp + timeOffset\n        });\n      }),\n      play: function play(ctx) {\n        var e_1, _a, e_2, _b;\n\n        var _c;\n\n        var timer = ctx.timer,\n            events = ctx.events,\n            baselineTime = ctx.baselineTime,\n            lastPlayedEvent = ctx.lastPlayedEvent;\n        timer.clear();\n\n        try {\n          for (var events_1 = __values(events), events_1_1 = events_1.next(); !events_1_1.done; events_1_1 = events_1.next()) {\n            var event_2 = events_1_1.value;\n            addDelay(event_2, baselineTime);\n          }\n        } catch (e_1_1) {\n          e_1 = {\n            error: e_1_1\n          };\n        } finally {\n          try {\n            if (events_1_1 && !events_1_1.done && (_a = events_1.return)) _a.call(events_1);\n          } finally {\n            if (e_1) throw e_1.error;\n          }\n        }\n\n        var neededEvents = discardPriorSnapshots(events, baselineTime);\n        var lastPlayedTimestamp = lastPlayedEvent === null || lastPlayedEvent === void 0 ? void 0 : lastPlayedEvent.timestamp;\n\n        if ((lastPlayedEvent === null || lastPlayedEvent === void 0 ? void 0 : lastPlayedEvent.type) === EventType.IncrementalSnapshot && lastPlayedEvent.data.source === IncrementalSource.MouseMove) {\n          lastPlayedTimestamp = lastPlayedEvent.timestamp + ((_c = lastPlayedEvent.data.positions[0]) === null || _c === void 0 ? void 0 : _c.timeOffset);\n        }\n\n        if (baselineTime < (lastPlayedTimestamp || 0)) {\n          emitter.emit(ReplayerEvents.PlayBack);\n        }\n\n        var syncEvents = new Array();\n        var actions = new Array();\n\n        var _loop_1 = function _loop_1(event_3) {\n          if (lastPlayedTimestamp && lastPlayedTimestamp < baselineTime && (event_3.timestamp <= lastPlayedTimestamp || event_3 === lastPlayedEvent)) {\n            return \"continue\";\n          }\n\n          if (event_3.timestamp < baselineTime) {\n            syncEvents.push(event_3);\n          } else {\n            var castFn_1 = getCastFn(event_3, false);\n            actions.push({\n              doAction: function doAction() {\n                castFn_1();\n              },\n              delay: event_3.delay\n            });\n          }\n        };\n\n        try {\n          for (var neededEvents_1 = __values(neededEvents), neededEvents_1_1 = neededEvents_1.next(); !neededEvents_1_1.done; neededEvents_1_1 = neededEvents_1.next()) {\n            var event_3 = neededEvents_1_1.value;\n\n            _loop_1(event_3);\n          }\n        } catch (e_2_1) {\n          e_2 = {\n            error: e_2_1\n          };\n        } finally {\n          try {\n            if (neededEvents_1_1 && !neededEvents_1_1.done && (_b = neededEvents_1.return)) _b.call(neededEvents_1);\n          } finally {\n            if (e_2) throw e_2.error;\n          }\n        }\n\n        applyEventsSynchronously(syncEvents);\n        emitter.emit(ReplayerEvents.Flush);\n        timer.addActions(actions);\n        timer.start();\n      },\n      pause: function pause(ctx) {\n        ctx.timer.clear();\n      },\n      resetLastPlayedEvent: o(function (ctx) {\n        return __assign(__assign({}, ctx), {\n          lastPlayedEvent: null\n        });\n      }),\n      startLive: o({\n        baselineTime: function baselineTime(ctx, event) {\n          ctx.timer.toggleLiveMode(true);\n          ctx.timer.start();\n\n          if (event.type === 'TO_LIVE' && event.payload.baselineTime) {\n            return event.payload.baselineTime;\n          }\n\n          return Date.now();\n        }\n      }),\n      addEvent: o(function (ctx, machineEvent) {\n        var baselineTime = ctx.baselineTime,\n            timer = ctx.timer,\n            events = ctx.events;\n\n        if (machineEvent.type === 'ADD_EVENT') {\n          var event_4 = machineEvent.payload.event;\n          addDelay(event_4, baselineTime);\n          var end = events.length - 1;\n\n          if (!events[end] || events[end].timestamp <= event_4.timestamp) {\n            events.push(event_4);\n          } else {\n            var insertionIndex = -1;\n            var start = 0;\n\n            while (start <= end) {\n              var mid = Math.floor((start + end) / 2);\n\n              if (events[mid].timestamp <= event_4.timestamp) {\n                start = mid + 1;\n              } else {\n                end = mid - 1;\n              }\n            }\n\n            if (insertionIndex === -1) {\n              insertionIndex = start;\n            }\n\n            events.splice(insertionIndex, 0, event_4);\n          }\n\n          var isSync = event_4.timestamp < baselineTime;\n          var castFn_2 = getCastFn(event_4, isSync);\n\n          if (isSync) {\n            castFn_2();\n          } else if (timer.isActive()) {\n            timer.addAction({\n              doAction: function doAction() {\n                castFn_2();\n              },\n              delay: event_4.delay\n            });\n          }\n        }\n\n        return __assign(__assign({}, ctx), {\n          events: events\n        });\n      })\n    }\n  });\n  return v(playerMachine);\n}\n\nfunction createSpeedService(context) {\n  var speedMachine = s({\n    id: 'speed',\n    context: context,\n    initial: 'normal',\n    states: {\n      normal: {\n        on: {\n          FAST_FORWARD: {\n            target: 'skipping',\n            actions: ['recordSpeed', 'setSpeed']\n          },\n          SET_SPEED: {\n            target: 'normal',\n            actions: ['setSpeed']\n          }\n        }\n      },\n      skipping: {\n        on: {\n          BACK_TO_NORMAL: {\n            target: 'normal',\n            actions: ['restoreSpeed']\n          },\n          SET_SPEED: {\n            target: 'normal',\n            actions: ['setSpeed']\n          }\n        }\n      }\n    }\n  }, {\n    actions: {\n      setSpeed: function setSpeed(ctx, event) {\n        if ('payload' in event) {\n          ctx.timer.setSpeed(event.payload.speed);\n        }\n      },\n      recordSpeed: o({\n        normalSpeed: function normalSpeed(ctx) {\n          return ctx.timer.speed;\n        }\n      }),\n      restoreSpeed: function restoreSpeed(ctx) {\n        ctx.timer.setSpeed(ctx.normalSpeed);\n      }\n    }\n  });\n  return v(speedMachine);\n}\n\nexport { createPlayerService, createSpeedService, discardPriorSnapshots };","map":null,"metadata":{},"sourceType":"module"}